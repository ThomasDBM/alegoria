<html>
    <head>
        <title>Itowns - Globe</title>

        <style type="text/css">
            #miniDiv {
                display: block;
                margin-bottom: 20px;
                margin-right: 20px;
                position: absolute;
                left: 20;
                bottom: 0;
                color: white;
            }
            #info {
                color: black;
                position: absolute;
                bottom: 0;
                right: 0;
                margin-right: 15px;
                padding: 0.3rem;
                background-color: rgba(255, 255, 255, 0.493);
                border: 2px solid black;
                border-radius: 5px;
                font-family: Arial, Helvetica, sans-serif;
                font-size: 11px;
            }
            .styleForm {
                text-align: center;
                display: block;
                margin-top: 00px;
                margin-left: 20px;
                position: absolute;
                color: black;
                font-family: 'Open Sans',
                sans-serif;
                font-size: 12px;
                left: 0;
                bottom: 10;
            }
            .buttonX {
                background-color: #4CAF50; /* Green */
                border: none;
                color: white;
                padding: 4px 4px;
                text-align: center; 
                text-decoration: none;
                display: inline-block;
                font-size: 12px;
                bottom: 0;
            }
            p { background-color:#FFFFFF; 
                color: black;
            }

            .imageholder{
                position: relative;
                float: right;
                vertical-align: middle;
                bottom: 10;
                left: 4;
            }
            
        </style>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../itowns-photogrammetric-camera/examples/css/example.css">
        <link rel="stylesheet" type="text/css" href="../itowns-photogrammetric-camera/examples/css/loading_screen.css">
        <link rel="stylesheet" type="text/css" href="scene2d.css">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="../itowns-photogrammetric-camera/examples/js/GUI/dat.gui/dat.gui.min.js"></script>
        <script src="../itowns-photogrammetric-camera/examples/js/OrientedImageHelper.js"></script>
        
    </head>
    <body>
           

        <div id="viewerDiv">
                <p id="info">
                        <img id="imgLogo" src="../data/logoAlegoria.jpg" onmousedown="getImgCoordOnClick(event)">
                        <br> 
                        <a href="http://www.archives-nationales.culture.gouv.fr/" target="_blank"> Images: Archives Nationales </a>
                </p>
            <!-- span class="divScaleWidget"> Scale </span>  -->
            <div id="miniDiv">
                <img id="img"  onmousedown="getImgCoordOnClick(event)">
            </div>
        </div>

        <form class="styleForm" method="post" enctype="multipart/form-data">
            <input type="file" name="files[]" multiple>
            <input type="submit" value="Upload File" name="submit">
            <p  class="imageholder" id="countPoints"> Points registered: 0</p>
            <button class="buttonX" type="button" onclick="computeResection(event, document.getElementById('img').src.split('/').pop(), true)">Go</button>
        </form>

        <script src="../itowns-photogrammetric-camera/examples/js/GUI/GuiTools.js"></script>
        <script src="../itowns-photogrammetric-camera/dist/itowns.js"></script>
        <script src="../itowns-photogrammetric-camera/examples/js/loading_screen.js"></script>
        <script src="../itowns-photogrammetric-camera/examples/js/ThreeLoader.js"></script>
        <script src="../itowns-photogrammetric-camera/dist/debug.js"></script>
        <script src="../itowns-photogrammetric-camera/examples/js/proj4defs/2154.js"></script>
        <script src="scene2d.js"></script>
        <script src="scene3dv2.js"></script>
        <script src="createCalibrationFile.js"></script>
        <script src="createMicmacChantierDescripteur.js"></script>
       
        <script type="text/javascript">

            // THREE photogrammetric camera variables
            var PhotogrammetricCamera = itowns.PhotogrammetricCamera;
            var MicmacOrientationParser = itowns.MicmacOrientationParser;
            var FetchSource = itowns.FetchSource;
            var OrientedImageMaterial = itowns.OrientedImageMaterial;
            var THREE = itowns.THREE;

            // Get possible parameters from url like imagename
            var urlpage = new URL(location);
            var imName = urlpage.searchParams.get("imgname");
            var posInit = urlpage.searchParams.get("pos");
            if(posInit) posInit = posInit.split(",");
            //console.log(imName, "  ", posInit);

            var orientedImageLayer;
            
            var pictureInfos;
            var camera;
            var camHelper;
            var plane;
            var orientedImage;
            var orientedImageGUI;
            var orientedMenu = false;
            var currentIndiceNav = 0;
            var currentImageName = "";
            var globalCurrentCamOriented;
            var currentOrientationWorkedImage = "x";
            var currentCameraScene;
            var meshes = [];
            var scaler;
            var textureMaterial;
            var currentOpacity = 1;
            var currentDistance = 100;
            var arrDisplayedImages = [];
            var meshesForeverever = [];
            var previewOn = false;
            var nearProj = 1;
            var farProj = 500;
            var target;
            var olayer;  // Oriented Image Layer
            var model; // 3D model loaded

            // Alex modifications to handle multiple images
            var arrayImages = [];
            arrayImages = [{image: 'LOC-04753X.jpg', distance: 200, opacity: 1, plane:null},
            {image: 'notredame.jpg', distance: 200, opacity: 1, plane:null},
            {image: 'rueVieilleDuTemple8.jpg', distance: 600, opacity: 1, plane:null},
            {image: 'planNotreDame.jpg', distance: 200, opacity: 1, plane:null},
            {image: 'plandetailleCite.jpg', distance: 200, opacity: 1, plane:null},
            {image: 'pontlouisphilippe.jpg', distance: 200, opacity: 1, plane:null},
            {image: '1919_CAF_C-1_0012.jpg', distance: 200, opacity: 1, plane:null}, 
            {image: '1951_DUR_208_0007.jpg', distance: 200, opacity: 1, plane:null},
            {image: '1951_DUR_214_0024.jpg', distance: 200, opacity: 1, plane:null}, 
            {image: '1951_DUR_214_0022.jpg', distance: 200, opacity: 1, plane:null},
            {image: '1919_CAF_Z-36_0008.jpg', distance: 200, opacity: 1, plane:null},
            {image: 'trocadero2.jpg', distance: 200, opacity: 1, plane:null},
            {image: 'FRAN_0207_3299_L.jpg', distance: 200, opacity: 1, plane:null},
            {image: 'FRAN_0207_0648_L.jpg', distance: 200, opacity: 1, plane:null}];
            if(imName !== null)
                arrayImages.unshift(  {image: imName, distance: 100, opacity: 1, plane:null} );
            
            // Define initial camera position  // 43.9542987,6.5115427 44.1751125,6.3516113,222m 44.1748836,6.3511125
            // var positionOnGlobe = { longitude: 2.3186303566461626, latitude: 48.86426741804917, altitude: 188.94939874485135 };
            // 42.7211829,1.8392353
            // 48.8365154,-3.3129326 ( rocher de la sentinelle)
            var positionOnGlobe = { longitude:2.3186303566461626, latitude: 48.86426741804917, altitude: 1878.615379151888 };
            if(posInit){ positionOnGlobe.longitude =  Number(posInit[1]); positionOnGlobe.latitude = Number(posInit[0]), positionOnGlobe.altitude =  Number(posInit[2]) || positionOnGlobe.altitude; }
            //console.log(positionOnGlobe);
            //var miniView;
            var minDistance = 10000000;
            var maxDistance = 30000000;

            var meshes = [];
            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            var viewerDiv = document.getElementById('viewerDiv');
            //var miniDiv = document.getElementById('miniDiv');

            // Instanciate iTowns view*
            var view = new itowns.GlobeView(viewerDiv, positionOnGlobe,{handleCollision: false,noControls: false,});
            view.camera.camera3D.near = 0.4;
            //  { sseSubdivisionThreshold: 6,
            //      noControls: false,
            //       handleCollision: false}

            //var view = view;
            setupLoadingScreen(viewerDiv, view);

            //3D point number
            var ptname = 0;

            // Add one imagery layer to the scene
            // This layer is defined in a json file but it could be defined as a plain js
            // object. See Layer* for more info.
            itowns.Fetcher.json('../itowns-photogrammetric-camera/examples/layers/JSONLayers/Ortho.json').then(function _(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layer = new itowns.ColorLayer('Ortho', config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            });

/*          // USA ORTHO WMTS
            itowns.Fetcher.json('../itowns-photogrammetric-camera/examples/layers/JSONLayers/us.json').then(function _(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layerUS = new itowns.ColorLayer('USGS', config);
                view.addLayer(layerUS).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            });
*/
            // Add two elevation layers.
            // These will deform iTowns globe geometry to represent terrain elevation.
            function addElevationLayerFromConfig(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layer = new itowns.ElevationLayer(config.id, config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            }
            itowns.Fetcher.json('../itowns-photogrammetric-camera/examples/layers/JSONLayers/WORLD_DTM.json').then(addElevationLayerFromConfig);
            itowns.Fetcher.json('../itowns-photogrammetric-camera/examples/layers/JSONLayers/IGN_MNT_HIGHRES.json').then(addElevationLayerFromConfig);

            var meshes = [];
            var color = new itowns.THREE.Color();
            function altitudeBuildings(properties) {
                //console.log(properties.z_min, properties.hauteur);
                return properties.z_min - properties.hauteur - 3;
            }

            function extrudeBuildings(properties) {
                if (properties.id.indexOf('bati_remarquable') === 0) 
                    return properties.hauteur;
                    else
                    return properties.hauteur + 20;
            }

            function acceptFeature(properties) {
                return !!properties.hauteur;
            }

            
            function colorBuildings(properties) {
                if (properties.id.indexOf('bati_remarquable') === 0) {
                    return color.set(0x5555ff);
                } else if (properties.id.indexOf('bati_industriel') === 0) {
                    return color.set(0xff5555);
                }
                return color.set(0xeeeeee);
            }

            function modifyAppearance(mesh){

              //  mesh.material = [mesh.material,new itowns.THREE.MeshBasicMaterial({wireframe:true})];
            }

            scaler = function update(/* dt */) {
                var i;
                var mesh;
                if (meshes.length) {
                    view.notifyChange(view.camera.camera3D, true);
                }
                for (i = 0; i < meshes.length; i++) {
                    mesh = meshes[i];
                    if (mesh) {
                        mesh.scale.z = Math.min(
                            1.0, mesh.scale.z + 0.1);
                        mesh.updateMatrixWorld(true);
                    }
                }
                meshes = meshes.filter(function filter(m) { return m.scale.z < 1; });
            };

            view.addFrameRequester(itowns.MAIN_LOOP_EVENTS.BEFORE_RENDER, scaler);


            var wfsBuildingSource = new itowns.WFSSource({
                url: 'https://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
                version: '2.0.0',
                typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie,BDTOPO_BDD_WLD_WGS84G:bati_industriel',
                projection: 'EPSG:4326',
                ipr: 'IGN',
                format: 'application/json',
                zoom: { min: 15, max: 15 },
              
            });

            var wfsBuildingLayer = new itowns.GeometryLayer('WFS Building', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh.convert({
                    color: colorBuildings,
                    batchId: function (property, featureId) { return featureId; },
                    altitude: altitudeBuildings,
                    extrude: extrudeBuildings }),
                onMeshCreated: function scaleZ(mesh) {
                    mesh.scale.z = 0.01;
                    meshes.push(mesh);
                    meshesForeverever.push(mesh);
                },
                filter: acceptFeature,
                overrideAltitudeInToZero: true,
                source: wfsBuildingSource
            });
            view.addLayer(wfsBuildingLayer);

            
/*
            // Test with geoserver Mathieu
            var wfsGeoserver = new itowns.WFSSource({
                url: 'http://134.158.74.36:8080/geoserver/alegoria/ows?',
                version: '1.0.0',
                typeName: 'alegoria%3Afrejus',
                projection: 'EPSG:4326',
                ipr: 'Alegoria',
                format: 'json',
                zoom: { min: 6, max: 15 },
              
            });

            var wfsGeoserverLayer = new itowns.GeometryLayer('WFS Geoserver', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh.convert({
                    color: console.log("coooocooo"),
                    batchId: function (property, featureId) { return featureId; },
                    altitude: function(){console.log(altitudeeeeeeeee);},
                    extrude: extrudeBuildings }),
               
                overrideAltitudeInToZero: true,
                source: wfsGeoserver
            });
            view.addLayer(wfsGeoserverLayer);
*/




            var menuGlobe = new GuiTools('menuDiv', view);



            // Listen for globe full initialisation event
            view.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function () {
                // eslint-disable-next-line no-console
                console.info('Globe initialized');
                //updateScaleWidget();
                // get 3D coordinates on mouse click
                window.addEventListener('mousedown', pickPosition, false);
                function pickPosition(event) {
                  
                    if(event.altKey){
                        // increment point number
                        ptname += 1;
                        document.getElementById('countPoints').innerHTML = "Points registered: " + ptname;
                        var pickBuilding = pickingBuildings(event);

                        if(pickBuilding.z == 0){
                            // get 3D coordinates on ground
                            geoposition = view.controls.pickGeoPosition(new itowns.THREE.Vector2(event.pageX,event.pageY));
                            //console.log(view.controls.pickGeoPosition(view.eventToViewCoords(event.altKey)));
                            // convert coordinates to geographic system
                            let converted = geoposition.as('EPSG:4978'); console.log(converted);
                            //coordinates = converted._values;
                            x = converted.x;
                            y = converted.y;
                            z = converted.z;
                        }
                        else{
                            x = pickBuilding.x, y = pickBuilding.y, z = pickBuilding.z;
                        }
                            
                        show3DPicking(x,y,z, ptname);
                        // export 3D coordinates to an xml file
                        export3Dcoord(ptname,x,y,z);
                        console.log("Nb of points picked: ", ptname);

                        // Launch computation after at least 3 points
                        if(ptname >= 4){
                            computeResection({}, document.getElementById('img').src.split('/').pop(), false);
                        }
                    }
                }

                // load3DModel();
            });


            // Picking on buildings
            function pickingBuildings(event) {
                var p3D = new itowns.THREE.Vector3();
                if(view.controls.isPaused()) {
                    var intersects = view.pickObjectsAt(event, 3, 'WFS Building');
                    if (intersects.length) {
                        //console.log(intersects[0].point);
                        p3D = intersects[0].point;
                    }
                }
                return p3D;
            }


            // ------ Upload Part --------------------------------------------------------------------------
            const url = 'process.php';
            const form = document.querySelector('form');

            form.addEventListener('submit', e => {
                e.preventDefault();

                const files = document.querySelector('[type=file]').files;
                const formData = new FormData();


                for (let i = 0; i < files.length; i++) {
                    let file = files[i];

                    formData.append('files[]', file);
                }
                console.log(form, formData, files, files[0].name);
                fetch(url, {
                    method: 'POST',
                    body: formData
                }).then(response => {
                    console.log(response);
                    document.getElementById("img").src= "../data/" + files[0].name;  // Get displayed image name
                    
                    
                    // Then we create (initialize) the 4 xml files needed. Ground points, 2D image point, camera calibration and the micmac chantier descriptor
                    setTimeout(function() {   // Ugly timer cause src change/affectation takes time and no callback used
                        arrayImages.unshift(  {image: files[0].name, distance: 100, opacity: 1, plane:null} );
                        initXML2D();
                        initXML3D();
                        createCalib(); // We create a calibration file knowing just the image size 
                        createMicmacChantierDescripteur(); // We create the micmac chantier descriptor
                    }, 1000);
                }); 
            });



/*
            view.controls.addEventListener(itowns.CONTROL_EVENTS.RANGE_CHANGED, () => {
                updateScaleWidget();
            });
*/
            // Draw a sphere to show where the 3D picking has been done
            function show3DPicking(x,y,z, iteration){

                var geometry = new itowns.THREE.SphereGeometry( 0.1, 16, 16 );
                var col = new itowns.THREE.Color(0XFFFF00);
                var material = new itowns.THREE.MeshBasicMaterial( {color: col.lerpHSL(new itowns.THREE.Color(0XFF0000), (iteration % 8) / 7), transparent:true, opacity:0.8} );
                var sphere = new itowns.THREE.Mesh( geometry, material );
                sphere.position.set(x,y,z); //console.log(sphere.position);
                sphere.updateMatrixWorld();
                view.scene.add( sphere );
                view.notifyChange();
            }


            function launchMicMac(event, imgName){
    
                var xmlhttp;
                if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
                    xmlhttp = new XMLHttpRequest();
                } else { // code for IE6, IE5
                    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                }

                xmlhttp.onreadystatechange = function() {
                    if (this.readyState == 4 && this.status == 200) {
                        console.log(this.responseText);
                        /*
                        var output_array = JSON.parse(this.responseText);
                        var output = output_array['output'];
                        var returned_value = output_array['status'];
                        console.log(output);
                        if(returned_value==0){
                            alert("MicMac calculations are done!");
                            window.location.href = 'oriented_images.html';
                            
                        }else{
                            alert("MicMac failed to calculate orientation, for more info press on F12");
                        }
                        */
                        window.open('globe.html?imgname=' + imgName);/*oriented_images*/
                    }
                };

                xmlhttp.open("GET", "launchMicMac.php" +"?"+ "imagename=" + imgName, true);
                xmlhttp.send();
            }
            
            // Launch micmac computation
            function computeResection(event, imgName, show){
                currentImageName = imgName;
                var xmlhttp;
                if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
                    xmlhttp = new XMLHttpRequest();
                } else { // code for IE6, IE5
                    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                }

                xmlhttp.onreadystatechange = function() {
                    if (this.readyState == 4 && this.status == 200) {
                        console.log(this.responseText);
                        // arrayImages.unshift(  {image: imgName, distance: 100, opacity: 1, plane:null} );
                        if(show) showResection();
                    }
                };
                xmlhttp.open("GET", "launchMicMac.php" +"?"+ "imagename=" + imgName, true);
                xmlhttp.send();
            }
            

            // Show oriented image using micmac aspro xml
            function showResection(){
                
                // fetch orientation file
                var source = new FetchSource('../outputs/test/');
                // parse micmac orientation
                source.open('Ori-Aspro/Orientation-' + arrayImages[currentIndiceNav].image + '.xml', 'text') // change orientation file each time you change the picture!
                    .then(data => MicmacOrientationParser.parse(data, source))
                    .then(handleOrientation);
            }

            
            // Show oriented image using micmac aspro xml
            function previewResection(){
                
                // fetch orientation file
                var source = new FetchSource('../outputs/test/');
                // parse micmac orientation
                source.open('Ori-Aspro/Orientation-' + arrayImages[currentIndiceNav].image + '.xml', 'text') // change orientation file each time you change the picture!
                    .then(data => MicmacOrientationParser.parse(data, source))
                    .then(handleOrientation);
            }



            /******************* Rendering functions **********************************************/
            
            
            /* Orientation loading */
            function cameraHelper(camera, mat) {
                var wireMaterial = new THREE.MeshBasicMaterial( {color: Math.random() * 0XFFFFFF, wireframe: true} );
                // create the group (looking at intrinsics only) that should be added to the camera frame.
                var group = new THREE.Group();
                // place a frustum
                {
                    m = new THREE.Matrix4().getInverse(camera.projectionMatrix);
                    var geometry = new THREE.BufferGeometry();
                    var vertices = new Float32Array(15);
                    // get the 4 corners on the near plane (neglecting distortion)
                    new THREE.Vector3( -1, -1, -1 ).applyMatrix4(m).toArray(vertices,  3);
                    new THREE.Vector3( -1,  1, -1 ).applyMatrix4(m).toArray(vertices,  6);
                    new THREE.Vector3(  1,  1, -1 ).applyMatrix4(m).toArray(vertices,  9);
                    new THREE.Vector3(  1, -1, -1 ).applyMatrix4(m).toArray(vertices, 12);
                    var indices = [ 0, 1, 2,  0, 2, 3,  0, 3, 4,  0, 4, 1,  1, 3, 2,  1, 4, 3 ];
                    geometry.setIndex( indices );
                    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
                    geometry.addGroup(0, 12, 0);
                    geometry.addGroup(12, 6, 1);
                    // viewMaterials[camera.name] = new OrientedImageMaterial(viewMaterialOptions);
                    // viewMaterials[camera.name].map = textures[camera.name] || uvTexture;
                    mat.map = uvTexture;
                    var mesh = new THREE.Mesh( geometry, [wireMaterial, mat] );
                    mesh.scale.set(1000, 1000, 1000);
                    group.add(mesh);
                }
                // place a sphere at the camera center
                {
                    var geometry = new THREE.SphereBufferGeometry(2, 8, 8 );
                    var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
                   // group.add(new THREE.Mesh( geometry, material ));
                }
                return group;
            };


            function setMaterial(material, camera) {
                material.map =  uvTexture; //textures[camera.name] || uvTexture;
                camera.getWorldPosition(material.uvwPosition);
                const m = new THREE.Matrix4().copy(camera.matrixWorldInverse);
                m.setPosition({x:0,y:0,z:0});
                material.uvwPreTransform.copy(camera.preProjectionMatrix).multiply(m);
                material.uvwPostTransform.copy(camera.postProjectionMatrix);
                if (camera.distos && camera.distos.length == 1 && camera.distos[0].type === 'ModRad') {
                    material.uvDistortion = camera.distos[0];
                } else {
                    material.uvDistortion = { C: new THREE.Vector2(), R: new THREE.Vector4() };
                    material.uvDistortion.R.w = Infinity;
                }
            }


            const uvTexture = new itowns.THREE.TextureLoader().load('../data/uv.jpg');
            

            // function to handle micmac orientation file
            function handleOrientation(cam) {
                console.log(cam);
                // Ugly way, if currently shown and refine orientation we remove oriented cam and recreate all...
                if(currentOrientationWorkedImage == currentImageName){
                    view.scene.remove(globalCurrentCamOriented);
                }

                currentOrientationWorkedImage = currentImageName;
                //view.camera._preSSE = 12000;  // Weird but needed to keep good tile resolution
                arrDisplayedImages.push(cam);
                textureMaterial = new OrientedImageMaterial({
                    map: new itowns.THREE.TextureLoader().load('../data/uv.jpg'), // uvTexture,
                   // tDepth: new itowns.THREE.TextureLoader().load('../data/uv.jpg'),
                    opacity:currentOpacity,
                    transparent:true,
                });
            
                setMaterial(textureMaterial, cam);

                camHelper = cameraHelper(cam, textureMaterial);
                var scale = currentDistance / 100;
                camHelper.scale.set(scale,scale,scale);
                cam.add(camHelper);
                cam.updateMatrixWorld();
                globalCurrentCamOriented = cam;
                view.scene.add(globalCurrentCamOriented);  
            // console.log(cam);
                var pictureInfos = arrayImages[currentIndiceNav];
                // camera set from micmac orientation file
                camera = cam;
                if(pictureInfos.plane == null){
                    plane = setupPictureFromCamera(camera, '../data/' + pictureInfos.image, pictureInfos.opacity, pictureInfos.distance); // plane is added to the photogra camara (so the scene)
                    pictureInfos.plane = plane;
                }else{
                    plane = pictureInfos.plane;
                }
                plane.visible = false;
/*
                var p2 = plane.clone();
                p2.position.multiplyScalar(1.0001);
                p2.updateMatrixWorld();
                view.scene.add(p2);
*/
                textureMaterial.map = new itowns.THREE.TextureLoader().load('../data/' + pictureInfos.image);
                textureMaterial.transparent = true;
                updateCamera();

                view.camera.camera3D.updateProjectionMatrix();
/*
                var geometry = new itowns.THREE.SphereGeometry( 20, 16, 16 );
                var sphere = new itowns.THREE.Mesh( geometry, textureMaterial);// textureMaterial);//new THREE.MeshBasicMaterial());
                sphere.material.side = THREE.DoubleSide;
                sphere.position.copy(cam.position.clone()); console.log(sphere.position);
                sphere.updateMatrixWorld();
                view.scene.add( sphere );
                view.notifyChange();
*/
                // set GUI for oriented image
                if(!orientedMenu){
                    orientedImageGUI = setupPictureUI(menuGlobe, pictureInfos, plane, updatePlaneDistance, updatePlaneOpacity, updateZoom, view, 1, 1000);  
                    orientedMenu = true; 
                }
                
                view.notifyChange(view.camera.camera3D);
                
            }

            // If no initial position passed in the URL we launch the first registered image
            if(! posInit){
                // fetch orientation file
                var source = new FetchSource('../outputs/test/');
                // parse micmac orientation
                source.open('Ori-Aspro/Orientation-' + arrayImages[currentIndiceNav].image + '.xml', 'text') // change orientation file each time you change the picture!
                    .then(data => MicmacOrientationParser.parse(data, source))
                    .then(handleOrientation);
            }

            function updatePlaneDistance(value) {
                transformTexturedPlane(camera, value, plane);//, pictureInfos.opacity);
                currentDistance = value;
                var scale = value / 100;
                camHelper.scale.set(scale,scale,scale);
                camHelper.updateMatrixWorld();
                view.notifyChange(view.camera.camera3D);
                //console.log(menuGlobe);
            }
           
            function updatePlaneOpacity(value) {
            //    console.log(value, plane);
                currentOpacity = value;
                textureMaterial.transparent = true;
                plane.material.opacity = value;
                textureMaterial.opacity = value;
                view.notifyChange(view.camera.camera3D);
            }

            function updateZoom(value) {
                
                view.camera.camera3D.zoom = value; 
                view.camera.camera3D.updateProjectionMatrix();
                view.notifyChange(view.camera.camera3D);

            //    console.log(view.camera);
            }

            // update camera and view
            function updateCamera() {
                setupViewCameraDecomposing(view, camera);
                //if (cameraHelper) cameraHelper.updateMatrixWorld(true);
                view.notifyChange(view.camera.camera3D);
            }

            function projectOnBuildings(){
                //console.log("projeccc", meshesForeverever);
                for(var m in meshesForeverever)
                    meshesForeverever[m].material = textureMaterial;      

                // Add background
                var copyBackground = olayer.background.clone();
                console.log(olayer);
                copyBackground.material = textureMaterial; //new THREE.MeshBasicMaterial(); //textureMaterial;
                copyBackground.position.addScalar(0.1);
                copyBackground.updateMatrixWorld();
                copyBackground.material.side = THREE.DoubleSide;
                copyBackground.material.transparent = true;
                copyBackground.material.opacity = 0.99;
                console.log("copyyyy", copyBackground);
                view.scene.add(copyBackground);
                view.notifyChange();

                 // set camera's layer to do not disturb the picking
                 model.traverse(function _(obj) { obj.material = textureMaterial;}) //console.log(obj);  /*obj.layers.set(colladaID); */ });

            }

            
            // eslint-disable-next-line no-unused-vars
            function menuNavigUI(menu, pictureInfos, subMenu) {

                var navImageGUI = subMenu; //menu.gui.addFolder('Navigation Image');
                var obj  = { next:function(){ nextImage() }};
                var obj2 = { projectOnBuildings:function(){projectOnBuildings()}};
                var obj3 = { resetPosition:function(){ resetPosition() }};
                var obj4 = { previewResection: function(){ previewResection() }};
                var obj5 = { fog: 0.};
                var obj6 = { near: nearProj};
                var obj7 = { far: farProj};
                var obj8 = { parallax: 0.};
                var obj9 = { activateStreetLevel: function(){ activateStreetLevel() }};
                
                navImageGUI.add(obj,'next');
                navImageGUI.add(obj2,'projectOnBuildings');
                navImageGUI.add(obj3,'resetPosition');
                navImageGUI.add(obj4,'previewResection');
                navImageGUI.add(obj5,'fog', 0., 1.).onChange(function setFogValue(value){textureMaterial.uniforms.foggy.value = value; view.notifyChange();});
                navImageGUI.add(obj6,'near', 8., 250.).onChange(function setNearValue(value){textureMaterial.uniforms.near.value = value; nearProj = value; createDepthMap(); view.notifyChange();});
                navImageGUI.add(obj7,'far', 8., 250.).onChange(function setFarValue(value){textureMaterial.uniforms.far.value = value; farProj = value; createDepthMap() ; view.notifyChange();});
                navImageGUI.add(obj8,'parallax', 0., 1.).onChange(function setParallaxValue(value){textureMaterial.uniforms.parallax.value = value; view.notifyChange();});
                navImageGUI.add(obj9,'activateStreetLevel');
                view.notifyChange(view.camera.camera3D);
            }

            // eslint-disable-next-line no-unused-vars
            function setupPictureUI(menu, pictureInfos, plane, updateDistanceCallback, updateOpacityCallback, updateFOVCallback, view, min, max) {
                var orientedImageGUI = menu.gui.addFolder('Oriented Image');

                orientedImageGUI.add(pictureInfos, 'distance', min, max).name('Distance').onChange(function distanceChanged(value) {
                    pictureInfos.distance = value;
                    updateDistanceCallback(value);
                    view.notifyChange();
                });

                orientedImageGUI.add(pictureInfos, 'opacity', 0, 1).name('Opacity').onChange(function opacityChanged(value) {
                    pictureInfos.opacity = value;
                    updateOpacityCallback(value);
                    view.notifyChange();
                });
                
                var pF = {zoom:1.};
                orientedImageGUI.add( pF, 'zoom', 0.01, 2.).name('Zoom').onChange(function fovChanged(value) {
                    //pictureInfos.opacity = value;
                    updateFOVCallback(value);
                    view.notifyChange();
                });

                var navMenu = menuNavigUI(menuGlobe, arrayImages, orientedImageGUI);
            }

            function nextImage(){
               // meshesForeverever = [];
                currentIndiceNav = (currentIndiceNav + 1) % arrayImages.length; console.log("currentIndiceNav ",currentIndiceNav);
                console.log('indice image: ', currentIndiceNav);

                source.open('Ori-Aspro/Orientation-' + arrayImages[currentIndiceNav].image + '.xml', 'text') // change orientation file each time you change the picture!
                .then(data => MicmacOrientationParser.parse(data, source))
                .then(handleOrientation);
                //view.notifyChange();
            }
            

            // Put scene camera back to original position (center of photocamera)
            function resetPosition(){
                updateCamera();
            }


            // Activate street level imagery
            function activateStreetLevel(){
                
                // create Immersive control
       /*         view.controls = new itowns.StreetControls(view, {
                    animationDuration: 50,
                });
        */
                // limit camera far, to increase performance
                view.camera.camera3D.near = 0.8;
         /*       view.camera.camera3D.far = 10000;
                view.camera.camera3D.near = 0.1;
                // open camera fov
                view.camera.camera3D.fov = 75;
                view.camera.camera3D.updateProjectionMatrix();
           */     // disable atmosphere
                view.getLayerById('atmosphere').visible = false;
                // Prepare oriented image source
                var orientedImageSource = new itowns.OrientedImageSource({  
                        url: 'Paris-140606_0713-{cameraId}-00001_0000{panoId}.jpg' //  // 2 Zero to remove 'CalibV4-140407_0566-{cameraId}-00008_0000{panoId}.jpg' // 'CalibV4-140407_0566-{cameraId}-00006_0000{panoId}.jpg' // 'Paris2015-150123_0593-{cameraId}-00004_0000{panoId}.jpg'//'Paris-150630_0723-{cameraId}-00005_0000{panoId}.jpg'  // 'CalibV4-140407_0566-{cameraId}-00006_0000{panoId}.jpg' 
                    });

                // Url to a GEOJSON file describing feature points. It describre position and orientation of each panoramic.
                var orientationsUrl = 'panoramicsMetaDataParis.geojson';
                var calibrationUrl = 'https://raw.githubusercontent.com/iTowns/iTowns2-sample-data/master/immersive/exampleParis1/cameraCalibration.json';

                // Fetch the two files
                var promises = [];
                var networkOptions = {crossOrigin: ''};
                promises.push(itowns.Fetcher.json(orientationsUrl, networkOptions) );
                promises.push(itowns.Fetcher.json(calibrationUrl, networkOptions) ) ;
                Promise.all(promises).then((res) => {

                    var orientation = res[0];
                    var calibration = res[1];

                    // Create oriented image layer
                    olayer = new itowns.OrientedImageLayer('demo_orientedImage', {
                        // Radius in meter of the sphere used as a background.
                        backgroundDistance: 450,
                        source: orientedImageSource,
                        orientation: orientation,
                        calibration: calibration,
                        projection: view.referenceCrs,
                        onPanoChanged: (e) => {
                        /*    view.controls.setPreviousPosition(e.previousPanoPosition);
                            view.controls.setCurrentPosition(e.currentPanoPosition);
                            view.controls.setNextPosition(e.nextPanoPosition);
                        */    }
                    });

                    // when oriented image layer is ready..
                    view.addLayer(olayer, view.tileLayer).then(function addWfsLayer(orientedImageLayer) {
                    
                        // prepare WFS source for the buildings
                        var wfsBuildingSource = new itowns.WFSSource({
                            url: 'https://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
                            version: '2.0.0',
                            typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie,BDTOPO_BDD_WLD_WGS84G:bati_industriel',
                            projection: 'EPSG:4326',
                            ipr: 'IGN',
                            format: 'application/json',
                            zoom: { min: 15, max: 15 },
                        });

                        // create geometry layer for the buildings
                        var wfsBuildingLayer = new itowns.GeometryLayer('Buildings', new itowns.THREE.Group(), {
                            update: itowns.FeatureProcessing.update,
                            convert: itowns.Feature2Mesh.convert({
                                altitude: altitudeBuildings,
                                extrude: extrudeBuildings }),

                            // when a building is created, it get the projective texture mapping, from oriented image layer.
                            onMeshCreated: (mesh) => mesh.traverse(object => object.material = orientedImageLayer.material),
                            source: wfsBuildingSource,
                            overrideAltitudeInToZero: true,
                        });

                        // add the created building layer, and debug UI
                        view.addLayer(wfsBuildingLayer).then(function addDebugUI(buildingLayer) {
                            var gui = debug.GeometryDebug.createGeometryDebugUI(menuGlobe.gui, view, buildingLayer);
                            debug.GeometryDebug.addWireFrameCheckbox(gui, view, buildingLayer);
                        });

                        // Test to project on a 3D model
                        // model.traverse(function _(obj) { obj.material = olayer.material; });
                    });

                 //   view.camera.camera3D.position.copy({x: 4200455.75402067, y: 173453.53384993714, z: 4780501.335775498});
                    view.notifyChange(view.camera.camera3D);
            /*        // set camera to current panoramic
                    view.controls.setCameraToCurrentPosition();
                    view.controls.moveCameraVertical(0.85);
                    view.notifyChange(view.camera.camera3D);
                    console.log(view.controls);
                    console.log(view.camera.camera3D);
                */    
                    console.log(olayer);
                 //   model.traverse(function _(obj) { obj.material = olayer.material; });
                    }
                
                    

                );
            }


            function centerCameraStreetView(){
                view.camera.camera3D.position.copy({x: 4199825.822840914, y: 172469.5643900863, z: 4781089.122163953}); //{x: 4200557.133126016, y: 172016.98119668392, z: 4780462.11547708});//{x: 4200012.882959826, y: 173338.79678516634, z: 4780896.915537954});//{x: 4200455.75402067, y: 173453.53384993714, z: 4780501.335775498});//{x: 4202444.187983729, y: 172504.46625564503, z: 4778798.559683817});//{x: 4199402.418293162, y: 170632.28074215917, z: 4781516.8235254865});//{x: 4200455.75402067, y: 173453.53384993714, z: 4780501.335775498});
                view.notifyChange(view.camera.camera3D);
            }



            // add debugging tools to GUI
            var d = new debug.Debug(view, menuGlobe.gui);
            debug.createTileDebugUI(menuGlobe.gui, view, view.tileLayer, d);


            // Ugly way to force refreshing the view 
            var time = 0;
            function updateView() {
               time++;
               if(time % 100 == 0){
                    view.notifyChange(view.camera.camera3D);
                    //console.log(view.controls);
               }
               window.requestAnimationFrame(updateView); 
            }

            updateView();


            for (var layer of view.getLayers()) {
               
                if (layer.id === 'WFS Building') {
                    layer.whenReady.then( function _(layer) {
                        var gui = debug.GeometryDebug.createGeometryDebugUI(menuGlobe.gui, view, layer);
                        debug.GeometryDebug.addWireFrameCheckbox(gui, view, layer);
                    });
                }
            }



        // Create depth map for registered images
        // It's dissociated between tile geometry and buildings... So we mix 2 technics
        function createDepthMap(){
            // itowns.renderViewToBuffer(view);
            // view.scene.overrideMaterial = new THREE.MeshDepthMaterial();
            // view.mainLoop.gfxEngine.renderer.shadowMap.enabled = true;
                 view.mainLoop.gfxEngine.renderer.preserveDrawingBuffer = true;
                 view.mainLoop.gfxEngine.renderer.autoClear = false;
                 view.mainLoop.gfxEngine.renderer.preserveDrawingBuffer = true;
                 var aspect =     view.camera.camera3D.aspect;
                 var fov =     view.camera.camera3D.fov;
                 var far =     view.camera.camera3D.far;
                 var near =     view.camera.camera3D.near;

                    view.camera.camera3D.aspect = camera.aspect;
                    view.camera.camera3D.fov = camera.fov;
                    view.camera.camera3D.near = nearProj;
                    view.camera.camera3D.far = farProj;
                    view.camera.camera3D.updateProjectionMatrix();

                  //  view.camera.camera3D.projectionMatrix = camera.preProjectionMatrix;
                    //view.scene.remove(globalCurrentCamOriented);
                    globalCurrentCamOriented.visible = false;
                 //   view.camera.camera3D.projectionMatrix = camera.projectionMatrix;
                 //   view.notifyChange(view.camera.camera3D);
                 //   view.camera.camera3D.updateProjectionMatrix();
                    // Create a multi render target with Float buffers
                    target = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
                    target.texture.format = THREE.RGBFormat;
                    target.texture.minFilter = THREE.NearestFilter;
                    target.texture.magFilter = THREE.NearestFilter;
                    target.texture.generateMipmaps = false;
                    target.stencilBuffer = false;
                    target.depthBuffer = true;
                    target.depthTexture = new THREE.DepthTexture();
                    target.depthTexture.type = THREE.UnsignedShortType;
                    view.notifyChange(view.camera.camera3D);
                    // render scene into target 
                  //  console.log(view.mainLoop.gfxEngine.renderer);
                    view.mainLoop.gfxEngine.renderer.setRenderTarget( target );
                    view.mainLoop.gfxEngine.renderer.render( view.scene, view.camera.camera3D );
                    //var texture = new THREE.DataTexture( buffer, view.camera.width, view.camera.height, THREE.RGBAFormat );
                    //texture.needsUpdate = true;
                    //textureMaterial.map = target.depthTexture;//texture//depthTexture;
                  //  textureMaterial.tDepth = target.depthTexture;
                    textureMaterial.uniforms.tDepth.value = target.depthTexture;
                    //textureMaterial.uniforms.foggy.value = 1.;
                    //view.notifyChange(view.camera.camera3D);
                    // Back to original cam
                    view.camera.camera3D.aspect = aspect;
                    view.camera.camera3D.fov = fov;
                    view.camera.camera3D.near = near;
                    view.camera.camera3D.far = far;
                    view.camera.camera3D.updateProjectionMatrix();

                    globalCurrentCamOriented.visible = true;
                    view.mainLoop.gfxEngine.renderer.setRenderTarget(null);
                    view.notifyChange(view.camera.camera3D);

        }    


        // SAVE THE DEPTH MAP FOR RE-USE AND OFFLINE USE 
        function saveDepthMap(){
            
            var img = view.mainLoop.gfxEngine.bufferToImage(target.depthBuffer, window.innerWidth, window.innerHeight);
            document.getElementById('miniDiv').appendChild(img);
            //console.log(target);
            /*
            var dataURL = view.mainLoop.gfxEngine.renderer.domElement.toDataURL();
            var img = new Image();
            img.src = dataURL;
            //console.log(img);
            document.getElementById('miniDiv').appendChild(img);
            */
                
        }

        function load3DModel(){
             // ThreeLoader can load each format proposed in ThreeJs examples loaders : https://github.com/mrdoob/three.js/tree/dev/examples/js/loaders
              var promiseCollada = ThreeLoader.load('GLTF', 'repuStatue/scene.gltf')
                .then(collada => {
                    model = collada.scene;

                    // building coordinate
                    var coord = new itowns.Coordinates('EPSG:4326', 2.36381, 48.86754, 30);
                    var colladaID = view.mainLoop.gfxEngine.getUniqueThreejsLayer();

                    model.position.copy(coord.as(view.referenceCrs));
                    // align up vector with geodesic normal
                    model.lookAt(model.position.clone().add(coord.geodesicNormal));
                    // user rotate building to align with ortho image
                    model.rotateX(Math.PI / 2);
                    model.rotateY(1.32 * Math.PI / 2);
                    model.scale.set(1., 1., 1.);

                    // set camera's layer to do not disturb the picking
                    model.traverse(function _(obj) { obj.layers.set(colladaID); });
                    //model.traverse(function _(obj) { obj.material = orientedImageLayer.material; });
                    view.camera.camera3D.layers.enable(colladaID);

                    // update coordinate of the mesh
                    model.updateMatrixWorld();

                    view.scene.add(model);
                    var light = new THREE.DirectionalLight( 0xffffff, 0.5 );
                    light.position.copy(coord.as(view.referenceCrs));
                    light.position.addScalar(30);
                    light.updateMatrixWorld();
                    view.scene.add( light ); 
                    view.notifyChange();
                });
        }

        /*********** Keyboard functions for preview of orientation ********************/
            document.addEventListener('keydown', (event) => {
                const keyName = event.key;
                if(keyName === 'r') {
                    if(!previewOn){
                        previewOn = true;
                        // save current scene camera position
                        currentCameraScene = {quaternion: view.camera.camera3D.quaternion.clone(), scale: view.camera.camera3D.scale.clone(), position: view.camera.camera3D.position.clone()};
                        //console.log(currentCameraScene);
                        // Launch preview of last computed orientation
                        previewResection();
                    }
                }
            }, false);

            document.addEventListener('keyup', (event) => {
                const keyName = event.key;
                if(keyName === 'r') {

                  //  createDepthMap();
                    previewOn = false;
                    setupViewCameraDecomposing(view, currentCameraScene);
                }
            }, false);

              /*********** Keyboard functions for preview of orientation ********************/
              document.addEventListener('keydown', (event) => {
                const keyName = event.key;
                if(keyName === 's') {
                    //saveDepthMap();
                    activateStreetLevel();
                }
            }, false);

            
              /*********** Keyboard functions for preview of orientation ********************/
              document.addEventListener('keydown', (event) => {
                const keyName = event.key;
                if(keyName === 'c') {
                    //saveDepthMap();
                    centerCameraStreetView();
                }
            }, false);

        </script>
    </body>
</html>
