<html>
    <head>
        <title>Alegoria Demo</title>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../itowns/examples/css/LoadingScreen.css">
        <link rel="stylesheet" type="text/css" href="css/scene2d.css">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
    </head>

    <body>

        <div id="viewerDiv">
                <a href="https://www.alegoria-project.fr"><img id="logo" src="data/logoAlegoria.jpg"/></a>
                <p id="info">
                        <br>
                        <a href="http://www.archives-nationales.culture.gouv.fr/" target="_blank"> Images: Archives Nationales </a>
                </p>
                <div class="container" id="containerIMG" style="display: grid;
                                                            color: white;
                                                            position: absolute;
                                                            bottom: 0;
                                                            right: 0;
                                                            border: 0px white solid;
                                                            height:0px;
                                                            width: 100%;
                                                            margin: 0;
                                                            padding: 0;
                                                            overflow: auto;
                                                            overflow-y: hidden;">
                                                            <table id="myTable">

                                                            </table>
                </div>

            <button id="buttonHideShow" class="styleButton">_</button>

            <div id="miniDiv">
                <img id="img"/>
            </div>


        </div>


        <div class="gotolocation" tabindex="-1">
            <input type="text" id="nameLocation" name="name" required minlength="1" size="20">
        </div>


        <form class="styleForm" method="post" enctype="multipart/form-data">
            <input type="file" name="files[]" multiple>
            <input type="submit" value="Upload File" name="submit">
            <p  class="imageholder" id="countPoints"> Points registered: 0</p>
            <button class="buttonX" type="button" id="goButton">Go</button>
        </form>
        <div id="metaData" class = "metaDataDisplay"></div>
        <div id="filtrage">
            <label class="switch">

                <input id= "switchButton" type="checkbox">
                <span class="sliders round"></span>
          </label>
        </div>

        <script src="../itowns/dist/itowns.js"></script>
        <script src="../itowns/dist/debug.js"></script>
        <script src="../itowns/examples/js/GUI/GuiTools.js"></script>
        <script src="../itowns/examples/js/GUI/LoadingScreen.js"></script>
        <script src="../itowns/examples/js/plugins/FeatureToolTip.js"></script>
        <script>
            var THREE = itowns.THREE;
        </script>
        <script src="../photogrammetric-camera/dist/photogrammetric-camera.js"></script>
        <script>
            var THREE_ = PhotogrammetricCamera.THREE_;
            var Parsers = PhotogrammetricCamera.Parsers;
            var Serializers = PhotogrammetricCamera.Serializers;
            var FetchSource = PhotogrammetricCamera.FetchSource;
            var FilesSource = PhotogrammetricCamera.FilesSource;
            var OrientedImageMaterial = PhotogrammetricCamera.OrientedImageMaterial;
            var NewMaterial = PhotogrammetricCamera.NewMaterial;
            var ShadowMapMaterial = PhotogrammetricCamera.ShadowMapMaterial;
            var RadialDistortion = PhotogrammetricCamera.Distortions.RadialDistortion;
            var PhotogrammetricCamera = PhotogrammetricCamera.PhotogrammetricCamera;
        </script>
        <script src="js/scene2d.js"></script>
        <script src="js/scene3dv2.js"></script>
        <script src="js/createCalibrationFile.js"></script>
        <script src="js/createMicmacChantierDescripteur.js"></script>
        <script src="js/addBuildingLayer.js"></script>
        <script src="js/addRasterLayers.js"></script>
        <script type="module">
            // Get possible parameters from url like imagename
            const urlSearchParams = new URL(location).searchParams;
            var imgName = urlSearchParams.get("imgname");
            var imName = imgName+".jpg";
            const locationParam = urlSearchParams.get("location");
            let posInit = urlSearchParams.get("pos");
            const wfsInURL = urlSearchParams.get("wfs");
            if(posInit) posInit = posInit.split(",");

            const defaultWFSCamera = 'alegoriaMerge2';

            var orientedImageLayer;

            var pictureInfos;
            var camera;
            var camHelper;
            var plane;
            var orientedImage;
            var orientedImageGUI;
            var orientedMenu = false;
            var currentIndiceNav = 0;
            var currentImageName = "";
            var globalCurrentCamOriented;
            var currentOrientationWorkedImage = "x";
            var currentCameraScene;
            var textureMaterial = new OrientedImageMaterial({
                    map: new itowns.THREE.TextureLoader().load('data/uv.jpg'),
                    transparent:true
                });
            var currentOpacity = 1;
            var currentDistance = 350;
            var arrDisplayedImages = [];
            var previewOn = false;
            var nearProj = 1;
            var farProj = 500;
            var target;
            var olayer;  // Oriented Image Layer
            var model; // 3D model loaded
            var arrAppariement = [];
            var currentObjUnderMouse;
            var lastObjUnderMouse;
            var firstMoveOut = false; // when mouse over leave camerahelper
            var scaleOff = false;
            var nbToModify = 0;  // Ugly init for animation
            var scalingOffisOn = false;
            var lowResValue = 128;
            var highResValue = 2048;
            var arrLoadedCameraNames = [];
            var previewModeOn = false;  // To handle the loading of super low resolution image like 128*128
            var mouseDown = false;
            var positionMouseDown = new THREE.Vector2();
            var mouseWheelOn = false;
            var imageSourcesInfo; // Object created at initialization getting infos through WFS on images url and other stuff
            var imageSourcesInfoDico = {};
            var currentDATADirectory = "data";
            // Images from Archives Nationales
            var imagesArchivesDico = {};
            var currentSource = 10;  // Name of the source of the image we register (alex (10) is default, other can be archives_nationales  (5) for example)

            var thumbnailWidth = 300;
            var thumbnailHeight = 165;

            var meshesForeverever = [];
            // var arrAppariementScene = [];
            // var arrAppariementOld = [];

            // Alex modifications to handle multiple images
            var arrayImages = [];
            arrayImages = [{image: '1957_DUR_452_0007.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0009.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0010.jpg', distance: 600, opacity: 1, plane:null},
            {image: '1957_DUR_452_0011_1.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0012.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0013.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0014.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0015.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0016.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0017.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0018.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0019.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0020.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0021.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0022.jpg', distance: 350, opacity: 1, plane:null},
            {image: 'pontlouisphilippe.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1919_CAF_C-1_0012.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1951_DUR_208_0007.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1951_DUR_214_0024.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1951_DUR_214_0022.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1919_CAF_Z-36_0008.jpg', distance: 350, opacity: 1, plane:null},
            {image: 'trocadero2.jpg', distance: 350, opacity: 1, plane:null},
            {image: 'FRAN_0207_3299_L.jpg', distance: 350, opacity: 1, plane:null},
            {image: 'FRAN_0207_0648_L.jpg', distance: 350, opacity: 1, plane:null}];
            if(imName !== null)
                arrayImages.unshift(  {image: imName, distance: 350, opacity: 1, plane:null} );

            // Define initial camera position  // 43.9542987,6.5115427 44.1751125,6.3516113,222m 44.1748836,6.3511125
            // var positionOnGlobe = { longitude: 2.3186303566461626, latitude: 48.86426741804917, altitude: 188.94939874485135 };
            // 42.7211829,1.8392353
            // 48.8365154,-3.3129326 ( rocher de la sentinelle)   // fprca: 43.9595975,5.7772372,

            itowns.proj4.defs('EPSG:2154', '+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
            var positionOnGlobe = { longitude:2.3186303566461626, latitude: 48.8642674180491, altitude: 1800 };
            if(posInit){ positionOnGlobe.longitude =  Number(posInit[1]); positionOnGlobe.latitude = Number(posInit[0]), positionOnGlobe.altitude =  Number(posInit[2]) || positionOnGlobe.altitude; }
            //console.log(positionOnGlobe);
            //var miniView;
            var minDistance = 10000000;
            var maxDistance = 30000000;
            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            var viewerDiv = document.getElementById('viewerDiv');
            //var miniDiv = document.getElementById('miniDiv');

            // Instanciate iTowns view
            var placement = {
                    coord: new itowns.Coordinates('EPSG:4326',  positionOnGlobe.longitude , positionOnGlobe.latitude),
                    range: positionOnGlobe.altitude,
                    tilt: 45,
                    heading: -60
            };
            var view = new itowns.GlobeView(viewerDiv, placement,{handleCollision: false, disableSkirt: false, noControls: false});
            view.mainLoop.gfxEngine.label2dRenderer.domElement.style.zIndex=-1;
            view.mainLoop.gfxEngine.renderer.domElement.style.zIndex=-2;
            setupLoadingScreen(viewerDiv, view);
            var menuGlobe = new GuiTools('menuDiv', view);
            menuGlobe.gui.close();

            view.camera.camera3D.near = 0.4;
            addRasterLayers(itowns, view, menuGlobe);

            var sceneAllCams = new THREE.Object3D();  // Object containg all oriented images cam
            view.scene.add(sceneAllCams);


            //3D point number
            var ptname = 0;
            loadImageSources();

            console.warn("MB : fix scrolling of containerIMG");
/* MB: todo
            $(document).ready(function() {
                $("#containerIMG").mousewheel(function(e, delta) {
                this.scrollLeft -= (delta * 200);
                //e.preventDefault();
                });
            });
*/
            function hideShow() {
                var x = document.getElementById("img");
                const show = x.style.display === "none";
                var button = document.getElementById("buttonHideShow");
		if (!x || !button) { console.error("img is not initialized yet"); return; }
                if (show) {
                    x.style.display = "block";
                    button.innerHTML = '_';
                } else {
                    x.style.display = "none";
                    button.innerHTML = '▢';
                }
            }
            document.getElementById("buttonHideShow").addEventListener("click", hideShow);
            document.getElementById("img").addEventListener("mousedown", getImgCoordOnClick);


            var color = new itowns.THREE.Color();

	    function geocode(text) {
                const url = "https://wxs.ign.fr/an7nvfzojv5wa96dsga5nk8w/look4/user/search?indices=locating&method=prefix&types=address%2Cposition%2Ctoponyme%2Cw3w&nb=1&match%5Bfulltext%5D=";
                return fetch(url + text)
                .then(response => response.json())
                .then(json => {
                    if (json.features.length==0) return undefined;
	            const coord = json.features[0].geometry.coordinates; console.log(coord);
                    return new itowns.Coordinates('EPSG:4326', coord[0], coord[1], coord[2]);
                });
	    }

            function travelTo(coord){
                    if (coord === undefined) return;
                    var pathTravel = [];
                    var timeTravel = 5000;
                    pathTravel.push({ range: 100000, time: timeTravel/2 , tilt: 80, heading: -50});
                    pathTravel.push({ coord: coord, range: 50000, time: timeTravel });
                    pathTravel.push({ range: 1400, time: timeTravel , tilt: 50, heading: -110 });
                    travel(pathTravel);
            }

            function travel(pathTravel) {
                var camera = view.camera.camera3D;
                return itowns.CameraUtils.sequenceAnimationsToLookAtTarget(view, camera, pathTravel);
            }


            // Creates a camera using the metadata (extrinseque, intraseque and image url file)
            function createCamFromMetaData(posM, properties){

                    // Let's download the image
                    // console.log("createCamFromMetaData: ", posM, properties);
                    var prop = properties; // m.feature.geometry[i].properties;
                    var imgName = prop.name; //console.log(prop);
                    var epsgquaternion = prop.epsgquaternion;
                    var source = prop.source; //console.log(imgName, epsgquaternion);

                    // We check if already image displayed we don't treat it
                    if(arrLoadedCameraNames.includes(imgName)) return 0;

                    arrLoadedCameraNames.push(imgName);

                    //https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/2324-0191/IGNF_PVA_1-0__1947-04-10__C2324-0191_1947_CDP2368_0002.jp2&LYR=20&WID=200&CVT=JPEG
                    // Dessous: url fonctionnant pour les PVA IGN en jp2 servies par le Geoportail
                    // var url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';
                    // var url = "data/" + imgName;  // Default url (imported image from user for registration)
                    //  if(imgName.includes("IGNF_PVA"))
                    //     url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';


                    // We construct the url using the source table
                    // imageSourcesInfoDico is already constructed using the source table
                    if(source != null){
                        var propSource = imageSourcesInfoDico['sources.' + source];
                        console.log(propSource);
			// console.log("poooooop", propSource);
                        if(propSource && propSource.iip != null)  // ex iip: "https://wxs.ign.fr/{key}/iipsrv.fcgi?FIF=DEMAT.PVA/{rlt}_{image}.jp2"
                            url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';
                            else if(propSource.highres != null)
                                url = propSource.highres.replace('{name}', imgName);//replace(/{name}/gi, )
                                else if(propSource.url != null)
                                    url = propSource.url + imgName;
                                    else
                                        url = "data/" + imgName;
                    }

                    var url = "http://localhost:5004/"+imgName+"/full/full/0/default.jpg";

                    // We check if image was inserted in database with extension ( avoid .jpg.jpg for example)
                    url = url.replace(".jpg.jpg", ".jpg");

                    // We now also add the image to the thumnails table (display them in 2d)
                    handleThumbnails("",{jpeg:url}, true);

                    // We then create a photogrammetric camera using the PVA properties
                    // Intrinsec properties
                    var focal =  [prop.fx, prop.fy];
                    var size = [prop.sx, prop.sy];
                    //[ 9100, 9500 ]; //prop.px * 2, prop.py * 2];
                    var point = [ prop.px, prop.py ];
                    var disto = [ new RadialDistortion(new THREE.Vector2(prop.cx, prop.cy), new THREE.Vector4(prop.c3, prop.c5, prop.c7, prop.cm)) ];
                    var imageMatrix = new THREE.Matrix4();
                    if(prop.m00 != undefined){  // If there are some Crop Infos, we set the image matrix (not identity)
                        imageMatrix.elements[0]  = prop.m00;
                        imageMatrix.elements[1]  = prop.m01;
                        imageMatrix.elements[4]  = prop.m10;
                        imageMatrix.elements[5]  = prop.m11;
                        imageMatrix.elements[12] = prop.m20;
                        imageMatrix.elements[13] = prop.m21;
                    }
                    var cameraP = new PhotogrammetricCamera(focal, size, point, 0, disto, undefined, undefined, undefined, imageMatrix );//, size, point, 0, [], 10, 10000); //, skew, distos, near, far);
                    // We inject the name of the image in the camera attributes
                    cameraP.name = url;
                    cameraP.originalName = imgName;
                    cameraP.propAdded = prop; // Dirty and naughty: we add all info we got to the photogrammetric camera object

                    // Extrinsec
                    var quaternion = new THREE.Quaternion(prop.qx, prop.qy, prop.qz, prop.qw); // console.log(m.feature.vertices.slice(i * 3, i * 3 + 3));
                    var pos = posM; // new THREE.Vector3().fromArray(m.feature.vertices.slice(i * 3, i * 3 + 3)); // console.log(pos); console.log(view.camera.camera3D.position);
                    cameraP.position.copy(pos);

                    // Here we need to check the coordinate system of the received camera
                    // If already EPSG:4978, nothing to do. If other, we need to compute the new orientation in our scene system (4978)
                    if(epsgquaternion != undefined && epsgquaternion != 4978){  // projectionCode
                        var coords = new itowns.Coordinates('EPSG:4978', pos.x, pos.y, pos.z);
                        var quat_crs2crs = itowns.OrientationUtils.quaternionFromCRSToCRS('EPSG:' + epsgquaternion, "EPSG:4978")(coords);
                        quaternion.premultiply(quat_crs2crs);
                    }


                    // Here we need to check the coordinate system of the received camera
                    // If already EPSG:4978, nothing to do. If other, we need to compute the new orientation in our scene system (4978)
                    if(epsgquaternion == undefined){  // projectionCode
                        var coords = new itowns.Coordinates('EPSG:4978', pos.x, pos.y, pos.z);
                        var quat_crs2crs = itowns.OrientationUtils.quaternionFromCRSToCRS('EPSG:2154' /*+ projectionCode*/, "EPSG:4978")(coords);
                        quaternion.premultiply(quat_crs2crs);
                    }

                    cameraP.quaternion.copy(quaternion);
                    createCameraHelper(cameraP);
                    handleOrientation(cameraP);
            }


            // Handles PVA representation when received from WFS
            // Load image and project it on the ground using the image properties
            function workWithMesh(m, projectionCode){

                //console.log(m);
                m.material.size = 25;
                for (var i = 0; i < m.feature.geometry.length; ++i){
                    // Let's download the image
                    // console.log(m.feature.geometry[i].properties.name);
                    var prop = m.feature.geometry[i].properties;
                    var imgName = prop.name; //console.log(prop);
                    var epsgquaternion = prop.epsgquaternion;
                    var source = prop.source; //console.log(imgName, epsgquaternion);

                    // We check if already image displayed we don't treat it
                    // BUGYYYYY its going out of the whole loop... It just need to jup this img
                    if(!arrLoadedCameraNames.includes(imgName)){

                        arrLoadedCameraNames.push(imgName);

                        //https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/2324-0191/IGNF_PVA_1-0__1947-04-10__C2324-0191_1947_CDP2368_0002.jp2&LYR=20&WID=200&CVT=JPEG
                        // Dessous: url fonctionnant pour les PVA IGN en jp2 servies par le Geoportail
                        // var url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';
                        var url = "data/" + imgName;  // Default url (imported image from user for registration)
                        //  if(imgName.includes("IGNF_PVA"))
                        //     url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';

                        // We construct the url using the source table
                        // imageSourcesInfoDico is already constructed using the source table
                        if(source != null){
                            var propSource = imageSourcesInfoDico['sources.' + source];
                            //   console.log("poooooop", propSource);
                            if(propSource.iip != null)  // ex iip: "https://wxs.ign.fr/{key}/iipsrv.fcgi?FIF=DEMAT.PVA/{rlt}_{image}.jp2"
                                url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';
                                else if(propSource.highres != null)
                                    url = propSource.highres.replace('{name}', imgName);//replace(/{name}/gi, )
                                    else if(propSource.url != null)
                                        url = propSource.url + imgName;
                                        else
                                            url = "data/" + imgName;
                        }


                        // We check if image was inserted in database with extension ( avoid .jpg.jpg for example)
                        url = url.replace(".jpg.jpg", ".jpg");

                        // We now also add the image to the thumnails table (display them in 2d)
                        handleThumbnails("",{jpeg:url}, true);

                        //url = "IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0826_xs.jpg";  // temp for test
                        //console.log(url);
                        // Temp to test with cropped image (Giordano)
                        //  if(url.includes("843"))
                        //   url ="http://134.158.75.67/alegoria/data/OIS-Reech_IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0843.jpg";

                        // We don't have a jp2 to jpg server (iip) yet so for the test we converted one image
                        // IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0826
                        //var pvaTexture = new itowns.THREE.TextureLoader().load('IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0826.jpg');

                        // We then create a photogrammetric camera using the PVA properties
                        // Intrinsec properties
                        var focal =  [prop.fx, prop.fy];
                        var size = [prop.sx, prop.sy];
                        //[ 9100, 9500 ]; //prop.px * 2, prop.py * 2];
                        var point = [ prop.px, prop.py ];
                        var disto = [ { type: "ModRad", C: new THREE.Vector2(prop.cx, prop.cy), R: new THREE.Vector4(prop.c3, prop.c5, prop.c7, prop.cm), project: RadialDistortion.project } ];
                        var imageMatrix = new THREE.Matrix4();
                        if(prop.m00 != undefined){  // If there are some Crop Infos, we set the image matrix (not identity)
                            imageMatrix.elements[0]  = prop.m00;
                            imageMatrix.elements[1]  = prop.m01;
                            imageMatrix.elements[4]  = prop.m10;
                            imageMatrix.elements[5]  = prop.m11;
                            imageMatrix.elements[12] = prop.m20;
                            imageMatrix.elements[13] = prop.m21;
                        }
                        var cameraP = new PhotogrammetricCamera(focal, size, point, 0, disto, undefined, undefined, undefined, imageMatrix );//, size, point, 0, [], 10, 10000); //, skew, distos, near, far);
                        // We inject the name of the image in the camera attributes
                        cameraP.name = url;
                        cameraP.originalName = imgName;
                        cameraP.propAdded = prop; // Dirty and naughty: we add all info we got to the photogrammetric camera object

                        // Extrinsec
                        var quaternion = new THREE.Quaternion(prop.qx, prop.qy, prop.qz, prop.qw); // console.log(m.feature.vertices.slice(i * 3, i * 3 + 3));
                        var pos = new THREE.Vector3().fromArray(m.feature.vertices.slice(i * 3, i * 3 + 3)); // console.log(pos); console.log(view.camera.camera3D.position);
                        cameraP.position.copy(pos);

                        // Here we need to check the coordinate system of the received camera
                        // If already EPSG:4978, nothing to do. If other, we need to compute the new orientation in our scene system (4978)
                        if(epsgquaternion != undefined && epsgquaternion != 4978){  // projectionCode
                            var coords = new itowns.Coordinates('EPSG:4978', pos.x, pos.y, pos.z);
                            var quat_crs2crs = itowns.OrientationUtils.quaternionFromCRSToCRS('EPSG:' + epsgquaternion, "EPSG:4978")(coords);
                            quaternion.premultiply(quat_crs2crs);
                        }


                        // Here we need to check the coordinate system of the received camera
                        // If already EPSG:4978, nothing to do. If other, we need to compute the new orientation in our scene system (4978)
                        if(epsgquaternion == undefined){  // projectionCode
                            var coords = new itowns.Coordinates('EPSG:4978', pos.x, pos.y, pos.z);
                            var quat_crs2crs = itowns.OrientationUtils.quaternionFromCRSToCRS('EPSG:2154' /*+ projectionCode*/, "EPSG:4978")(coords);
                            quaternion.premultiply(quat_crs2crs);
                            //quaternion.multiply(new THREE.Quaternion(1,0,0,0));
                        }

                        cameraP.quaternion.copy(quaternion);

                        /*
                        if(url.includes("843")) {console.log("CAM 843: cameraP: ",cameraP, "prop: ", prop);
                            url = "OIS-Reech_IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0843FromMathieu.jpg";
                            cameraP.name = url;
                        }
                        */

                        createCameraHelper(cameraP);
                        // m.add(sceneAllCams);
                    }
                    //m.add(sceneAllCams);
                    /*
                    handleOrientation(cameraP);
                    textureMaterial.map = pvaTexture;   // ! Dirty ! Asynchronous with camHelper creation...
                    textureMaterial.transparent = true;
                    */
                }
            }


  /*
            // Access archives_nationales WFS
            var wfsGeoserverSourceAN = new itowns.WFSSource({
                url: 'http://134.158.75.67:8080/geoserver/alegoria/ows?',
                protocol:'wfs',
                version: '2.0.0',
                typeName: 'archives_nationales', // 'alegoria%3Ananterre_1960_2314_1701_full', //'alegoria%3Ananterre_1960_2314_1701_full',//'alegoria%3Aforcalquier',//'alegoria%3Afrejus',
                crs: 'EPSG:4326',
                fetcher: itowns.Fetcher.json,
                parser: itowns.GeoJsonParser.parse,
                ipr: 'Alegoria',
                format: 'json',
                zoom: { min: 14, max: 14 },
                networkOptions: {crossOrigin: ''}
            });

            var wfsGeoserverLayerAN = new itowns.GeometryLayer('WFS Geoserver Archives Nationales', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh.convert({
                    playWithProperties: playWithProperties,
                    color: new itowns.THREE.Color() }),
              //  overrideAltitudeInToZero: true,
                onMeshCreated: function(mesh){showImageInfo(mesh,'EPSG:4326');},
                source: wfsGeoserverSourceAN
            });
            view.addLayer(wfsGeoserverLayerAN);
*/


            // What do we do with archives images (not registered a priori)
            function showImageInfo(m, proj){
                for (var i = 0; i < m.feature.geometry.length; ++i){

                    //if(arrImagesArchives.imgName return 0;

                    var prop = m.feature.geometry[i].properties;
                    if(imagesArchivesDico[prop.jpeg] == undefined){
                        imagesArchivesDico[prop.jpeg] = prop;
                        //console.log(m.feature.geometry[i], prop);
                        var pos = new itowns.Coordinates('EPSG:4326',  prop.longitude , prop.latitude, 250).as('EPSG:4978');
                        var geometry = new itowns.THREE.SphereGeometry( 80, 4, 4 );
                        var material = new itowns.THREE.MeshBasicMaterial( {color:new itowns.THREE.Color(0XFF0000), transparent:true, opacity:0.1} );
                        var sphere = new itowns.THREE.Mesh( geometry, material );
                        sphere.position.set(pos.x, pos.y, pos.z); // console.log(sphere.position);
                        sphere.updateMatrixWorld();
                        view.scene.add( sphere );

                        handleThumbnails("http://134.158.75.67/images/archives_nationales/", prop, false);//.jpeg);
                    }
                }
                // console.log(imagesArchivesDico);
                view.notifyChange();
                // m.material.size = 250;
                // m.material.color = new THREE.Color('red');
                // console.log(m);
                var keys = Object.keys( imagesArchivesDico );
                var imgOBJ = keys[0];
            }


            function handleThumbnails(urlSource, prop, georeferenced){

                var img = new Image(thumbnailWidth, thumbnailHeight); //document.createElement('img');
                img.src = urlSource  + prop.jpeg; // "http://134.158.75.67/images/archives_nationales/FRAN_0207_0155_L.jpg";
                // img.nameAlegoria = img.src;
                img.alegoriaProp = prop;
                img.georeferenced = georeferenced;
                if(georeferenced){
                    img.style.cssText = " border: 4px solid #2FA1D6";
                }
                //console.log(img.src);
                var table = document.getElementById('myTable');
                var nbRows = table.rows.length;
                let currentRow;
                if(nbRows < 1) // Happens only once
                    currentRow = table.insertRow(-1);
                else
                    currentRow = table.rows[0];

                img.onload = function() {
                    var realWidth = img.naturalWidth;
                    var realHeight = img.naturalHeight;
                    img.width = realWidth / (realHeight / 168);
                    var col = currentRow.insertCell(0);
                    col.appendChild(img);
                    img.addEventListener("click", displayImage);
                    img.addEventListener("mouseenter", displayMetaData);
                };

            }


            // This function displays the selected image (thumbnail) in bigger to make the resection
            // OR if already registered direclty in front of CameraIMAGE
            function displayImage(evt){

                evt.cancelBubble = true;
                var currentImgProp = evt.target.alegoriaProp;
                //console.log("click image", currentImgProp);
                // console.log(sceneAllCams.children);
               // console.log("arrrrrrrrrrrrrrrrrrr", arrLoadedCameraNames, currentImgProp.jpeg);
                // We first check if image is registered or not using a WFS request (TOTO)
                // temporarly for a test, we just check the already loaded CameraImage
                var imgName = currentImgProp.jpeg.substring((currentImgProp.jpeg.lastIndexOf('/') + 1));

                // If iip url we recover the original imgName to look for it in camera names array
                if (currentImgProp.jpeg.lastIndexOf('&CVT') >=0 ){
                    var start =  currentImgProp.jpeg.lastIndexOf('.PVA');
                    var end = currentImgProp.jpeg.lastIndexOf('.jp2');
                    imgName = currentImgProp.jpeg.substring(start + 5, end);
                }

                if(arrLoadedCameraNames.includes(imgName)){   //currentImgProp.jpeg

                    //console.log('Image ' + currentImgProp.jpeg + 'already georeferenced');
                    var sceneCAMS = sceneAllCams.children;
                    var camImg;
                    var a = 0;
                    var found = false;
                    while(a < sceneCAMS.length && !found){
                        if(sceneCAMS[a].name.indexOf(currentImgProp.jpeg) >= 0 ){
                            camImg = sceneCAMS[a];
                            found = true;
                        }
                        a++;
                    }
                    handleOrientation(camImg);
                }

                else{   // We show the image in order for the user to register it

                    currentDATADirectory = "../../images/archives_nationales";
                    currentSource = 5;
                    document.getElementById('img').src =  "http://134.158.75.67/images/archives_nationales/" + currentImgProp.jpeg;

                    // Then we create (initialize) the 4 xml files needed. Ground points, 2D image point, camera calibration and the micmac chantier descriptor
                    setTimeout(function() {   // Ugly timer cause src change/affectation takes time and no callback used
                        arrayImages.unshift(  {image: currentImgProp.jpeg, distance: 100, opacity: 1, plane:null} );
                        initXML2D(currentImgProp.jpeg);
                        initXML3D(currentImgProp.jpeg);
                        createCalib(); // We create a calibration file knowing just the image size
                        createMicmacChantierDescripteur(); // We create the micmac chantier descriptor
                        }, 1000);
                    }
            }


            function displayMetaData(evt){
                var currentImgProp = evt.target.alegoriaProp;
                var divMeta = document.getElementById('metaData');
               // if(currentImgProp.description == null) currentImgProp.description = "";
               // if(currentImgProp.city == null) currentImgProp.city = "";

                var desc = currentImgProp.number + " | " + currentImgProp.cote + " | " + currentImgProp.mission + " | " +
                currentImgProp.dpt_new + " | " + currentImgProp.support + " | " + currentImgProp.producer + " | " +
                currentImgProp.description + " | " + currentImgProp.city + " | " + currentImgProp.jpeg + " | " +
                currentImgProp.latitude + " | " + currentImgProp.longitude;
                const regex = /\| null/gi;
                divMeta.innerHTML = desc.replace(regex, "");
                //JSON.stringify(currentImgProp);
            }


            // Access to our Geoservers (On ISC) to get registered cameras  (ex alegoriaMerge2)
            var wfsGeoserverSource = new itowns.WFSSource({
                url: 'http://134.158.75.67:8080/geoserver/alegoria/ows?',
                protocol:'wfs',
                version: '2.0.0',
                typeName: wfsInURL || defaultWFSCamera, // 'alegoria%3Ananterre_1960_2314_1701_full', //'alegoria%3Ananterre_1960_2314_1701_full',//'alegoria%3Aforcalquier',//'alegoria%3Afrejus',
                crs: 'EPSG:4978',
                fetcher: itowns.Fetcher.json,
                parser: itowns.GeoJsonParser.parse,
                ipr: 'Alegoria',
                format: 'json',
                zoom: { min: 7, max: 7 },
                networkOptions: {crossOrigin: ''}
            });


            var wfsGeoserverLayer = new itowns.GeometryLayer('WFS Geoserver', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh.convert({
                    //playWithProperties: playWithProperties,
                    //color: new itowns.THREE.Color()
                  }),
                onMeshCreated: function(mesh){workWithMesh(mesh,'EPSG:4978');},//workWithMesh(mesh),
                source: wfsGeoserverSource
            });
            view.addLayer(wfsGeoserverLayer);



            // Test all France Mathieu DB
            // Access to our Geoservers (On ISC) to get registered cameras  (ex alegoriaMerge2)
            var wfsGeoserverSourceTA = new itowns.WFSSource({
                url: 'http://134.158.75.67:8080/geoserver/alegoria/ows?',
                protocol:'wfs',
                version: '2.0.0',
                typeName: 'alegoria_ta2', //wfsInURL || defaultWFSCamera, // 'alegoria%3Ananterre_1960_2314_1701_full', //'alegoria%3Ananterre_1960_2314_1701_full',//'alegoria%3Aforcalquier',//'alegoria%3Afrejus',
                crs: 'EPSG:2154',
                fetcher: itowns.Fetcher.json,
                parser: itowns.GeoJsonParser.parse,
                ipr: 'Alegoria',
                format: 'json',
                zoom: { min: 16, max: 16 },
                networkOptions: {crossOrigin: ''}
            });


            var wfsGeoserverLayerTA = new itowns.GeometryLayer('WFS Geoserver TA', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh.convert({
                    //playWithProperties: playWithProperties,
                  //  color: new itowns.THREE.Color()
                  }),
                onMeshCreated: function(mesh){workWithMesh(mesh,'EPSG:2154');},//workWithMesh(mesh),
                source: wfsGeoserverSourceTA
            });
        //    view.addLayer(wfsGeoserverLayerTA);



            // Function to load at initialization
            function loadImageSources(){

                fetch('http://134.158.75.67:8080/geoserver/alegoria/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=alegoria%3Asources&outputFormat=application%2Fjson').then(
                        function(response) {
                            if (response.status !== 200) {
                                console.log('Looks like there was a problem. Status Code: ' + response.status);
                                return;
                            }
                            response.json().then(function(data) {
                                 imageSourcesInfo = data;
                                // We construct a dictionnary to improve access speed for later on
                                for( var i= 0; i< imageSourcesInfo.features.length; ++i ){
                                    var feat = imageSourcesInfo.features[i];
                                    imageSourcesInfoDico[feat.id] = feat.properties;
                                }
                                 // console.log(imageSourcesInfo, imageSourcesInfoDico);
                            });
                        }
                    ).catch(function(err) {
                        console.log('Fetch Error :-S', err);
                    });

            }


            // Listen for globe full initialisation event
            view.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function () {
                // eslint-disable-next-line no-console
                console.info('Globe initialized');
                // Put Ortho to back
                itowns.ColorLayersOrdering.moveLayerToIndex(view, 'Ortho', 0);
                window.addEventListener('mousedown', pickPosition, false);
                function pickPosition(event) {

                    if(event.altKey){
                        // increment point number
                        ptname += 1;
                        document.getElementById('countPoints').innerHTML = "Points registered: " + ptname;
                        var pickBuilding = pickingBuildings(event);

			let x = pickBuilding.x;
			let y = pickBuilding.y;
			let z = pickBuilding.z;


                        if(pickBuilding.z == 0){
                            // get 3D coordinates on ground
                            const geoposition = view.controls.pickGeoPosition(new itowns.THREE.Vector2(event.pageX,event.pageY));
                            const converted = geoposition.as('EPSG:4978');
                            x = converted.x;
                            y = converted.y;
                            z = converted.z;
                        }

                        show3DPicking(x,y,z, ptname);
                        // export 3D coordinates to an xml file
                        export3Dcoord(ptname,x,y,z);
                        console.log("Nb of points picked: ", ptname);

                        // Launch computation after at least 3 points
                        if(ptname >= 4){
                            computeResection({}, imName, false);
                        }
                    }
                }

                // If the user specified an imgName in the url, we request the WFS to go to it
                if(imName !== null){
                    console.log("accessing image specified in URL: ", imName);
                    //fetch('http://134.158.75.67/alegoriaX/src/data/test/Ori-Aspro/Orientation-LAPIE1_FRAN_0207_1992_L.jpg.xml').then(console.log)

                // fetch orientation file
                var source = new FetchSource('data/test/');
                // parse micmac orientation
		const name = 'Orientation-' + imName + '.xml';
                source.open('Ori-Aspro/'+name, 'text')
                    .then(data => Parsers.MicmacParser.parse(data, source, name))
                    .then(handleOrientation);
		// change orientation file each time you change the picture!
            





/*
                    var url = "http://134.158.75.67:8080/geoserver/alegoria/ows?SERVICE=WFS&REQUEST=GetFeature&typeName=alegoriaMerge2&VERSION=2.0.0&outputFormat=json&CQL_FILTER=name=%27" + imName + "%27";
                    fetch(url)
                    .then( response => response.json() )
                    .then((myJson) => {
                        console.log(myJson);
                        var feat = myJson.features[0];
                        createCamFromMetaData(new THREE.Vector3(feat.geometry.coordinates[0],feat.geometry.coordinates[1],feat.geometry.coordinates[2]) ,feat.properties);
                        if(arrLoadedCameraNames.includes(imName)){
                            var sceneCAMS = sceneAllCams.children;
                            var camImg;
                            var a = 0;
                            var found = false;
                            while(a < sceneCAMS.length && !found){
                                if(sceneCAMS[a].name.indexOf(imName) >= 0 ){
                                    camImg = sceneCAMS[a];
                                    found = true;
                                }
                                a++;
                            }
                            handleOrientation(camImg);
                            }
                    });
*/

                }

            });


            // Picking on buildings
            function pickingBuildings(event) {
                var p3D = new itowns.THREE.Vector3();
                if(view.controls.isPaused) {
                    var intersects = view.pickObjectsAt(event, 3, 'WFS Building');
                    if (intersects.length) {
                        //console.log(intersects[0].point);
                        p3D = intersects[0].point;
                    }
                }
                return p3D;
            }


            // ------ Upload Part --------------------------------------------------------------------------
            const url = 'php/process.php';
            const form = document.querySelector('form');

            form.addEventListener('submit', e => {
                currentDATADirectory = "data";
                currentSource = 10; // default alex source
                e.preventDefault();

                const files = document.querySelector('[type=file]').files;
                const formData = new FormData();

                for (let i = 0; i < files.length; i++) {
                    let file = files[i];

                    formData.append('files[]', file);
                }
                imgName = files[0].name;
                //console.log(form, formData, files, files[0].name);
                fetch(url, {
                    method: 'POST',
                    body: formData
                }).then(response => {
                    // console.log(response);
                    document.getElementById("img").src = "data/" + files[0].name;  // Get displayed image name


                    // Then we create (initialize) the 4 xml files needed. Ground points, 2D image point, camera calibration and the micmac chantier descriptor
                    setTimeout(function() {   // Ugly timer cause src change/affectation takes time and no callback used
                        arrayImages.unshift(  {image: files[0].name, distance: 100, opacity: 1, plane:null} );
                        initXML2D(files[0].name);
                        initXML3D(files[0].name);
                        createCalib(); // We create a calibration file knowing just the image size
                        createMicmacChantierDescripteur(); // We create the micmac chantier descriptor
                    }, 1000);
                });
            });



/*
            view.controls.addEventListener(itowns.CONTROL_EVENTS.RANGE_CHANGED, () => {
                updateScaleWidget();
            });
*/
            // Draw a sphere to show where the 3D picking has been done
            function show3DPicking(x,y,z, iteration){

                var geometry = new itowns.THREE.SphereGeometry( 2.5, 16, 16 );
                var col = new itowns.THREE.Color(0XFFFF00);
                var material = new itowns.THREE.MeshBasicMaterial( {color: col.lerpHSL(new itowns.THREE.Color(0XFF0000), (iteration % 8) / 7), transparent:true, opacity:0.8} );
                var sphere = new itowns.THREE.Mesh( geometry, material );
                sphere.position.set(x,y,z); //console.log(sphere.position);
                sphere.updateMatrixWorld();
                view.scene.add( sphere );
                view.notifyChange();
            }


            function launchMicMac(event, imgName){
		console.log("launchMicMac");
                var xmlhttp;
                if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
                    xmlhttp = new XMLHttpRequest();
                } else { // code for IE6, IE5
                    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                }

                xmlhttp.onreadystatechange = function() {
                    if (this.readyState == 4 && this.status == 200) {
                        //console.log(this.responseText);
                        /*
                        var output_array = JSON.parse(this.responseText);
                        var output = output_array['output'];
			output = output.replace('\\n','\n');
                        var returned_value = output_array['status'];
                        console.log(output);
                        if(returned_value==0){
                            alert("MicMac calculations are done!");
                            window.location.href = 'oriented_images.html';

                        }else{
                            alert("MicMac failed to calculate orientation, for more info press on F12");
                        }
                        */
                        window.open('globe.html?imgname=' + imgName);/*oriented_images*/
                    }
                };

                xmlhttp.open("GET", "php/launchMicMac.php" +"?"+ "imagename=" + imgName + "&dir=" + currentDATADirectory, true);
                xmlhttp.send();
            }


            // Launch micmac computation
            function computeResection(event, imgName, show){
                console.log("Computing resection of image: ", imgName);
                currentImageName = imgName;
                var xmlhttp;
                if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
                    xmlhttp = new XMLHttpRequest();
                } else { // code for IE6, IE5
                    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                }

                xmlhttp.onreadystatechange = function() {
                    if (this.readyState == 4 && this.status == 200) {
                        var json = JSON.parse(this.responseText);
			json.output = json.output.replace('\\n','\n');
                        console.log(json.input,json.output);
                        if(show) showResection();
                    }
                };
                xmlhttp.open("GET", "php/launchMicMac.php" +"?"+ "imagename=" + imName + "&dir=" + currentDATADirectory, true);
                xmlhttp.send();
            }

            // Show oriented image using micmac aspro xml
            function showResection(){

                // fetch orientation file
                var source = new FetchSource('data/test/');
                // parse micmac orientation
		const name = 'Orientation-' + arrayImages[currentIndiceNav].image + '.xml';
                source.open('Ori-Aspro/'+name, 'text')
                    .then(data => Parsers.MicmacParser.parse(data, source, name))
                    .then(handleOrientation);
		// change orientation file each time you change the picture!
            }


            /******************* Rendering functions **********************************************/


            /* Orientation loading */
            function cameraHelper(camera, mat) {
                var wireMaterial = new THREE.MeshBasicMaterial( {color: Math.random() * 0XFFFFFF, wireframe: true} );
                // create the group (looking at intrinsics only) that should be added to the camera frame.
                var group = new THREE.Group();
                // place a frustum
                {
                    const m = new THREE.Matrix4().copy(camera.projectionMatrix).invert();
                    var geometry = new THREE.BufferGeometry();
                    var vertices = new Float32Array(15);
                    // get the 4 corners on the near plane (neglecting distortion)
                    new THREE.Vector3( -1, -1, -1 ).applyMatrix4(m).toArray(vertices,  3);
                    new THREE.Vector3( -1,  1, -1 ).applyMatrix4(m).toArray(vertices,  6);
                    new THREE.Vector3(  1,  1, -1 ).applyMatrix4(m).toArray(vertices,  9);
                    new THREE.Vector3(  1, -1, -1 ).applyMatrix4(m).toArray(vertices, 12);
                    var indices = [ 0, 1, 2,  0, 2, 3,  0, 3, 4,  0, 4, 1,  1, 3, 2,  1, 4, 3 ];
                    geometry.setIndex( indices );
                    geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
                    geometry.addGroup(0, 12, 0);
                    geometry.addGroup(12, 6, 1);
                    // viewMaterials[camera.name] = new OrientedImageMaterial(viewMaterialOptions);
                    // viewMaterials[camera.name].map = textures[camera.name] || uvTexture;
                    // mat.map = uvTexture;
                    var mesh = new THREE.Mesh( geometry, [wireMaterial, mat] );
                    mesh.scale.set(200, 200, 200);
                    group.add(mesh);
                }
                // place a sphere at the camera center
                {
                    var geometry = new THREE.SphereBufferGeometry(2, 8, 8 );
                    var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
                    // group.add(new THREE.Mesh( geometry, material ));
                }
                return group;
            };

            // Function to export the photogrammetric camera to the Database through WFS
            function saveCamToWFS(){
                exportToWFS(camera, "alegoriaMerge2", currentSource);  // Previously successfully tested with table alegoria5
            }

            // Uncomment playvideo
            function playVideo(){

                var videoName =  "data/pontneufCropped.mp4"; //pictureInfos.image;
                var x = document.createElement("VIDEO");
                x.setAttribute("id", "video");
                if (x.canPlayType("video/mp4")) {
                    x.setAttribute("src",videoName);
                }
                x.setAttribute("width", "840");
                x.setAttribute("height", "700");
                x.setAttribute("controls", "controls");
                document.body.appendChild(x);
                var video = document.getElementById( 'video' );
     //video.play();
                var texture = new THREE.VideoTexture( video );//  console.log(video, texture);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.format = THREE.RGBFormat;
                textureMaterial.map = texture;
                updateRenderingAlwaysForVideo();

                // Faisceaux
                showFaisceaux();
            }


            function updateRenderingAlwaysForVideo(){

                view.notifyChange();
                requestAnimationFrame( updateRenderingAlwaysForVideo );

             };


            const uvTexture = new itowns.THREE.TextureLoader().load('data/uv.jpg');


            // function to handle micmac orientation file
            function handleOrientation(cam) {
                 console.log("Handle Orientation of cam: ",cam);
                // Ugly way, if currently shown and refine orientation we remove oriented cam and recreate all...
                if(currentOrientationWorkedImage == currentImageName){
                    view.scene.remove(globalCurrentCamOriented);
                }

                currentOrientationWorkedImage = currentImageName;
                //view.camera._preSSE = 12000;  // Weird but needed to keep good tile resolution
                arrDisplayedImages.push(cam);

                // Already set in case of DB WFS. We can set here the High Resolution image (TODO)
                if(true) { // cam.name === ""){  // Old school XML
                    textureMaterial.setCamera(cam);
                    camHelper = cameraHelper(cam, textureMaterial);
                    var scale = currentDistance / 100;
                    camHelper.scale.set(scale,scale,scale);
                    cam.add(camHelper);
                    cam.updateMatrixWorld();
                    view.scene.add(cam);
                    // camera set from micmac orientation file
                }

                globalCurrentCamOriented = cam;
                camera = cam;
                var pictureInfos = arrayImages[currentIndiceNav];

                // Dirty mod to handle previous version with the new DB WFS one
                if(cam.name === ""){ // Old School XMl

                    console.log("cam.name  null", cam);
                    if(pictureInfos.plane == null){
                        plane = setupPictureFromCamera(camera, currentDATADirectory  + "/" + pictureInfos.image, pictureInfos.opacity, pictureInfos.distance); // plane is added to the photogra camara (so the scene)
                        pictureInfos.plane = plane; console.log("picturesinfos.planeee: ", plane);
                    }else{
                        plane = pictureInfos.plane;
                    }
                    plane.visible = false;
                    cam.name = cam.originalName = pictureInfos.image;
                    textureMaterial.map = new itowns.THREE.TextureLoader().load(currentDATADirectory + "/" + pictureInfos.image);
                }else{  // WFS Mode
                    // We update the image with a bigger resolution
                    console.log("cam.namecam.namecam.namecam.name: ",cam.name);
                    cam.name =  cam.name.replace("WID=" + lowResValue, "WID=" + highResValue);
                    textureMaterial.map = new itowns.THREE.TextureLoader().load("http://search-engine.alegoria-project.fr/api/v0_1/images/"+cam.name);
                    console.log("textureMaterial.map ",textureMaterial.map);
                    /*
                    var textureMaterialP = new OrientedImageMaterial({
                        map: new itowns.THREE.TextureLoader().load(cam.name), // new itowns.THREE.TextureLoader().load('data/uv.jpg'),
                        opacity:currentOpacity,
                        transparent:true,
                    });

                    textureMaterialP.setCamera(cam);
                    */
                }

                textureMaterial.transparent = true;
                updateCamera();

                view.camera.camera3D.updateProjectionMatrix();

                // set GUI for oriented image
                if(!orientedMenu){
                    orientedImageGUI = setupPictureUI(menuGlobe, pictureInfos, plane, updatePlaneDistance, updatePlaneOpacity, updateZoom, view, 150, 1000);
                    orientedMenu = true;
                }

                view.notifyChange(view.camera.camera3D);
            }


            // Function that create cameraHelper with all the properties of the oriented image
            // Picking on it to associate camera scene
            function createCameraHelper(cam){
                console.log("createCameraHelper for cam: ", cam.name);
                // console.log(cam);
                // Concerning the texture, Ideally we initiate with a low res (thumbnail) and then
                // when the user chooses that camera it'll load HiRes.
                // Low res should be found using camera name + "lowres".jpg for example or more dynamically
                // using IIP Image jp2 multi res
                var textureMaterialP = new OrientedImageMaterial({
                    map: new itowns.THREE.TextureLoader().load(cam.name), // new itowns.THREE.TextureLoader().load('data/uv.jpg'),
                    opacity:currentOpacity,
                    transparent:true,
                    side: THREE.DoubleSide
                });

                textureMaterialP.setCamera(cam);
                var camHelper = cameraHelper(cam, textureMaterialP);
                var scale = currentDistance / 100;
                camHelper.scale.set(scale,scale,scale);
                cam.add(camHelper);
                cam.updateMatrixWorld();
                sceneAllCams.add(cam);
                // console.log(cam);
                // view.scene.add(cam);
            }

/*
            // If no initial position passed in the URL we launch the first registered image
            if(! posInit && arrayImages.length > 0){
                // fetch orientation file
                var source = new FetchSource('data/test/');
                // parse micmac orientation
		const name = 'Orientation-' + arrayImages[currentIndiceNav].image + '.xml';
                source.open('Ori-Aspro/' + name, 'text') // change orientation file each time you change the picture!
                    .then(data => Parsers.MicmacParser.parse(data, source, name))
                    .then(handleOrientation);
            }
*/


            function updatePlaneDistance(value) {

                currentDistance = value;
                var scale = value / 100;
                currentObjUnderMouse.scale.set(scale,scale,scale);
                view.notifyChange(view.camera.camera3D);
            }

            function updatePlaneOpacity(value) {
                currentOpacity = value;
                textureMaterial.transparent = true;
                if(plane) plane.material.opacity = value;
                textureMaterial.opacity = value;
                view.notifyChange(view.camera.camera3D);
            }

            function updateZoom(value) {

                view.camera.camera3D.zoom = value;
                view.camera.camera3D.updateProjectionMatrix();
                view.notifyChange(view.camera.camera3D);

            //    console.log(view.camera);
            }

            // update camera and view
            function updateCamera() {
                setupViewCameraDecomposing(view, camera);
                //if (cameraHelper) cameraHelper.updateMatrixWorld(true);
                view.notifyChange(view.camera.camera3D);
            }

            function projectOnBuildings(){
                for(var m in meshesForeverever)
                    meshesForeverever[m].material = textureMaterial;

                // Add background for Street Level
                if(olayer){
                    var copyBackground = olayer.background.clone();
                    console.log(olayer);
                    copyBackground.material = textureMaterial; //new THREE.MeshBasicMaterial(); //textureMaterial;
                    copyBackground.position.addScalar(0.1);
                    copyBackground.updateMatrixWorld();
                    copyBackground.material.side = THREE.DoubleSide;
                    copyBackground.material.transparent = true;
                    copyBackground.material.opacity = 0.99;
                    console.log("copyyyy", copyBackground);
                    view.scene.add(copyBackground);
                    view.notifyChange();
                  }

                 // set camera's layer to do not disturb the picking
                 //  model.traverse(function _(obj) { obj.material = textureMaterial;}) //console.log(obj);  /*obj.layers.set(colladaID); */ });

            }


            // eslint-disable-next-line no-unused-vars
            function menuNavigUI(menu, pictureInfos, subMenu) {

                var navImageGUI = subMenu; //menu.gui.addFolder('Navigation Image');
                var obj  = { next:function(){ nextImage() }};
                var obj2 = { projectOnBuildings:function(){projectOnBuildings()}};
                var obj3 = { resetPosition:function(){ resetPosition() }};
                var obj4 = { previewResection: function(){ showResection() }};
                var obj5 = { fog: 0.};
                var obj6 = { near: nearProj};
                var obj7 = { far: farProj};
                var obj8 = { parallax: 0.};
                var obj11 = { saveRegistration: function(){ saveCamToWFS() /* playVideo(); */ }};
                var obj12 = { date: 1951};

                navImageGUI.add(obj,'next');
                navImageGUI.add(obj2,'projectOnBuildings');
                navImageGUI.add(obj3,'resetPosition');
                navImageGUI.add(obj4,'previewResection');
                navImageGUI.add(obj5,'fog', 0., 1.).onChange(function setFogValue(value){textureMaterial.uniforms.foggy.value = value; view.notifyChange();});
                navImageGUI.add(obj6,'near', 8., 250.).onChange(function setNearValue(value){textureMaterial.uniforms.near.value = value; nearProj = value; createDepthMap(); view.notifyChange();});
                navImageGUI.add(obj7,'far', 8., 250.).onChange(function setFarValue(value){textureMaterial.uniforms.far.value = value; farProj = value; createDepthMap() ; view.notifyChange();});
                navImageGUI.add(obj8,'parallax', 0., 1.).onChange(function setParallaxValue(value){textureMaterial.uniforms.parallax.value = value; view.notifyChange();});
                navImageGUI.add(obj11,'saveRegistration');
                navImageGUI.add(obj12,'date', 1940, 1980).onChange(function filterD(value){filterDates(value); view.notifyChange();});
                view.notifyChange(view.camera.camera3D);
            }

            // eslint-disable-next-line no-unused-vars
            function setupPictureUI(menu, pictureInfos, plane, updateDistanceCallback, updateOpacityCallback, updateFOVCallback, view, min, max) {
                var orientedImageGUI = menu.gui.addFolder('Oriented Image');

                orientedImageGUI.add(pictureInfos, 'distance', min, max).name('Distance').onChange(function distanceChanged(value) {
                    pictureInfos.distance = value;
                    updateDistanceCallback(value);
                    view.notifyChange();
                });

                orientedImageGUI.add(pictureInfos, 'opacity', 0, 1).name('Opacity').onChange(function opacityChanged(value) {
                    pictureInfos.opacity = value;
                    updateOpacityCallback(value);
                    view.notifyChange();
                });

                var pF = {zoom:1.};
                orientedImageGUI.add( pF, 'zoom', 0.01, 2.).name('Zoom').onChange(function fovChanged(value) {
                    //pictureInfos.opacity = value;
                    updateFOVCallback(value);
                    view.notifyChange();
                });

                var navMenu = menuNavigUI(menuGlobe, arrayImages, orientedImageGUI);
            }

            function nextImage(){
                currentIndiceNav = (currentIndiceNav + 1) % arrayImages.length;
                console.log('indice image: ', currentIndiceNav);

		const name = 'Orientation-' + arrayImages[currentIndiceNav].image + '.xml';
                source.open('Ori-Aspro/'+name, 'text')
                .then(data => Parsers.MicmacParser.parse(data, source, name))
                .then(handleOrientation);
                //view.notifyChange();
            }


            // Put scene camera back to original position (center of photocamera)
            function resetPosition(){
                updateCamera();
            }

            addBuildingLayer(itowns, view);


            function centerCameraStreetView(){
                view.camera.camera3D.position.copy({x: 4200418.678760414, y: 169697.9663647849, z: 4780662.507142361});//{x: 4199575.751513691, y: 170654.7421699525, z: 4781364.212254677});  //{x: 4199779.782905031, y: 171024.8334730191, z: 4781177.511110922}); // {x: 4199820.888875769, y: 171052.74504265454, z: 4781140.971902925}); //{x: 4199825.822840914, y: 172469.5643900863, z: 4781089.122163953}); //{x: 4200557.133126016, y: 172016.98119668392, z: 4780462.11547708});//{x: 4200012.882959826, y: 173338.79678516634, z: 4780896.915537954});//{x: 4200455.75402067, y: 173453.53384993714, z: 4780501.335775498});//{x: 4202444.187983729, y: 172504.46625564503, z: 4778798.559683817});//{x: 4199402.418293162, y: 170632.28074215917, z: 4781516.8235254865});//{x: 4200455.75402067, y: 173453.53384993714, z: 4780501.335775498});
                view.notifyChange(view.camera.camera3D);
            }



            // add debugging tools to GUI
            var d = new debug.Debug(view, menuGlobe.gui);
            debug.createTileDebugUI(menuGlobe.gui, view, view.tileLayer, d);


            // Ugly way to force refreshing the view
            var time = 0;
            function updateView() {
               time++;
               if(time % 100 == 0){
                    view.notifyChange(view.camera.camera3D);
                    //console.log(view.controls);
               }
               window.requestAnimationFrame(updateView);
            }

            updateView();


            for (var layer of view.getLayers()) {

                if (layer.id === 'WFS Building') {
                    layer.whenReady.then( function _(layer) {
                        var gui = debug.GeometryDebug.createGeometryDebugUI(menuGlobe.gui, view, layer);
                        debug.GeometryDebug.addWireFrameCheckbox(gui, view, layer);
                    });
                }
            }

            console.log("sceneAllCams", sceneAllCams);

            // Changes XML to JSON
            function xmlToJson(xml) {

                // Create the return object
                var obj = {};

                if (xml.nodeType == 1) { // element
                    // do attributes
                    if (xml.attributes.length > 0) {
                    obj["@attributes"] = {};
                        for (var j = 0; j < xml.attributes.length; j++) {
                            var attribute = xml.attributes.item(j);
                            obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
                        }
                    }
                } else if (xml.nodeType == 3) { // text
                    obj = xml.nodeValue;
                }

                // do children
                if (xml.hasChildNodes()) {
                    for(var i = 0; i < xml.childNodes.length; i++) {
                        var item = xml.childNodes.item(i);
                        var nodeName = item.nodeName;
                        if (typeof(obj[nodeName]) == "undefined") {
                            obj[nodeName] = xmlToJson(item);
                        } else {
                            if (typeof(obj[nodeName].push) == "undefined") {
                                var old = obj[nodeName];
                                obj[nodeName] = [];
                                obj[nodeName].push(old);
                            }
                            obj[nodeName].push(xmlToJson(item));
                        }
                    }
                }
                return obj;
            };


        // Create depth map for registered images
        // It's dissociated between tile geometry and buildings... So we mix 2 technics
        function createDepthMap(){
                 view.mainLoop.gfxEngine.renderer.preserveDrawingBuffer = true;
                 view.mainLoop.gfxEngine.renderer.autoClear = false;
                 view.mainLoop.gfxEngine.renderer.preserveDrawingBuffer = true;
                 var aspect =     view.camera.camera3D.aspect;
                 var fov =     view.camera.camera3D.fov;
                 var far =     view.camera.camera3D.far;
                 var near =     view.camera.camera3D.near;

                    view.camera.camera3D.aspect = camera.aspect;
                    view.camera.camera3D.fov = camera.fov;
                    view.camera.camera3D.near = nearProj;
                    view.camera.camera3D.far = farProj;
                    view.camera.camera3D.updateProjectionMatrix();

                    globalCurrentCamOriented.visible = false;
                    target = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
                    target.texture.format = THREE.RGBFormat;
                    target.texture.minFilter = THREE.NearestFilter;
                    target.texture.magFilter = THREE.NearestFilter;
                    target.texture.generateMipmaps = false;
                    target.stencilBuffer = false;
                    target.depthBuffer = true;
                    target.depthTexture = new THREE.DepthTexture();
                    target.depthTexture.type = THREE.UnsignedShortType;
                    view.notifyChange(view.camera.camera3D);
                    // render scene into target
                    view.mainLoop.gfxEngine.renderer.setRenderTarget( target );
                    view.mainLoop.gfxEngine.renderer.render( view.scene, view.camera.camera3D );
                    textureMaterial.uniforms.tDepth.value = target.depthTexture;
                    view.camera.camera3D.aspect = aspect;
                    view.camera.camera3D.fov = fov;
                    view.camera.camera3D.near = near;
                    view.camera.camera3D.far = far;
                    view.camera.camera3D.updateProjectionMatrix();

                    globalCurrentCamOriented.visible = true;
                    view.mainLoop.gfxEngine.renderer.setRenderTarget(null);
                    view.notifyChange(view.camera.camera3D);

        }

        // Save scene to image in local
        function saveAsImageLocally() {
            var imgData, imgNode;
            var strDownloadMime = "image/octet-stream";
            try {
                var strMime = "image/jpeg";
                view.mainLoop.gfxEngine.renderView(view);
                imgData = view.mainLoop.gfxEngine.renderer.domElement.toDataURL(strMime);
                saveFile(imgData.replace(strMime, strDownloadMime), "test.jpg");
            } catch (e) {
                console.log(e);
                return;
            }
        }

        var saveFile = function (strData, filename) {
            var link = document.createElement('a');
            if (typeof link.download === 'string') {
                document.body.appendChild(link); //Firefox requires the link to be in the body
                link.download = filename;
                link.href = strData;
                link.click();
                document.body.removeChild(link); //remove the link when done
            } else {
                location.replace(uri);
            }
        }


        // Function that reads appariement results and get 3D point and write both gcp.xml and appuis.xml
        function readAppariement(){
            // Default url for results: http://134.158.75.67/alegoriaX/src/pts_image1_image2.resultfiltre
            //jQuery.get('pts_image1_image2.resultfiltre', function(data) {
            fetch('pts_image1_image2.resultfiltre').then(function(data) {
                arrAppariement = data.split(/\s+/);
                console.log(arrAppariement);  // Xa0,Ya0,Xb0,Yb0,Xa1,Ya1,...,Xan,Yan,Xbn,Ybn

                // We then launch the creation of the GCP and Appuis files
                createHomologuePointFiles();
            });

        }

        // We reproject the 2D points homologues in the Scene to get 3D coordinates
        function createHomologuePointFiles(){
            for(var i = 0; i < arrAppariement.length -1; i+=4){

                var pScene = {x:Number(arrAppariement[i]), y: Number(arrAppariement[i + 1])};
                var pPhoto = {x:Number(arrAppariement[i + 2]), y: Number(arrAppariement[i + 3])};
                var pickBuilding = pickingBuildings(pScene);
                var geoposition = new THREE.Vector3();
                if(pickBuilding.z == 0){
                    // get 3D coordinates on ground
                    geoposition = view.controls.pickGeoPosition(new itowns.THREE.Vector2(pScene.x, pScene.y));
                    // convert coordinates to geographic system
                    if(typeof geoposition != "undefined"){
                        var converted = geoposition.as('EPSG:4978'); // console.log(converted);
                        //coordinates = converted._values;
                        pickBuilding.x = converted.x;
                        pickBuilding.y = converted.y;
                        pickBuilding.z = converted.z;
                    }
                }
                //if(pick)
                console.log(pickBuilding, pScene);
                if(pickBuilding.z !==0){
                    show3DPicking(pickBuilding.x, pickBuilding.y, pickBuilding.z, ptname);
                    // export 3D coordinates to an xml file
                    export3Dcoord(ptname, pickBuilding.x, pickBuilding.y, pickBuilding.z);
                    export2DCoord(ptname, pPhoto.x, pPhoto.y);
                    ptname++;
                }
            }

            // We can finally now launch Aspro
            setTimeout(function() {   // Ugly timer cause src change/affectation takes time and no callback used
                    computeResection({}, imName, true);
                }, 650);
        }

        /*********** Keyboard/Mouse functions for preview of orientation ********************/
            var raycaster = new THREE.Raycaster();
            var mouse = new THREE.Vector2();

            function onMouseMove( event ) {
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                // update the picking ray with the camera and mouse position
	            raycaster.setFromCamera( mouse, view.camera.camera3D );
                // calculate objects intersecting the picking ray
                var intersects = raycaster.intersectObjects(sceneAllCams.children, true);  // "true" for recursive raycast
                if(intersects.length && intersects.length > 0){
                    activateCamHelper(intersects[ 0 ].object.parent);
                    firstMoveOut = true;
                }

                if (intersects.length == 0 && firstMoveOut && !scalingOffisOn){
                    firstMoveOut = false;
                    scalingOffCamHelpers();
                }
            }

            function onMouseClick( event ){
                var mouse = new THREE.Vector2();
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                // update the picking ray with the camera and mouse position
	            raycaster.setFromCamera( mouse, view.camera.camera3D );
                // calculate objects intersecting the picking ray
                var intersects = raycaster.intersectObjects(sceneAllCams.children, true);  // "true" for recursive raycast
                if (intersects.length && intersects.length > 0){
                    // We put the scene camera like was the camera that took the selected photo
                    console.log("cliiiick", intersects[ 0 ].object.parent);
                    handleOrientation(intersects[ 0 ].object.parent.parent);
                }
            }

            window.addEventListener( 'mousemove', onMouseMove, false );
            window.addEventListener('mousedown', e => {
                positionMouseDown = new THREE.Vector2(e.clientX, e.clientY);
                mouseDown = true;
            });
            window.addEventListener('mouseup', e => {
                mouseDown = false;
                if(positionMouseDown.distanceTo(new THREE.Vector2(e.clientX, e.clientY)) < 2)
                    onMouseClick(e);
            });

            window.addEventListener('wheel', event => {mouseWheelOn = true;});

            // Function to show dynamically the camHelper under the mouse
            function activateCamHelper(obj){
                currentObjUnderMouse = obj;  // console.log("undermouse: ",obj);
                textureMaterial = obj.children[0].material[1];
                scaleCamHelper();
            }


            function scaleCamHelper(){

               if(currentObjUnderMouse.scale.x < 10){
                    currentObjUnderMouse.scale.addScalar(0.4);
                    currentObjUnderMouse.updateMatrixWorld();
                    view.notifyChange();
                    requestAnimationFrame( scaleCamHelper );
                }
            }


            function scalingOffCamHelpers(){
                scalingOffisOn = true;
                // console.log('scalingOff', nbToModify);
                nbToModify = 0;
                for(var i = 0; i < sceneAllCams.children.length; ++i){
                    var o = sceneAllCams.children[i].children[0];
                   if(o.scale.x > 4){
                        o.scale.addScalar(-0.4);
                        o.updateMatrixWorld();
                        view.notifyChange();
                        nbToModify = 1;
                    }
                }
                if(nbToModify > 0){
                    scaleOff = true;
                    requestAnimationFrame( scalingOffCamHelpers );
                }
                else{
                    firstMoveOut = false; scaleOff = false; scalingOffisOn = false;
                }
            }


            document.addEventListener('keydown', (event) => {
                const keyName = event.key;
                var target = event.target || event.srcElement;
                var targetTagName = (target.nodeType == 1) ? target.nodeName.toUpperCase() : "";
                //console.log(event, targetTagName);

                if(event.key == "Enter") {  // We use geocoder...

                    var lieu = document.getElementById("nameLocation").value;
                    geocode(lieu).then(travelTo);

                }

                if ( !/INPUT|SELECT|TEXTAREA/.test(targetTagName) ) {


                    if(keyName === 'r') {
                        if(!previewOn){
                            previewOn = true;
                            // save current scene camera position
                            currentCameraScene = {quaternion: view.camera.camera3D.quaternion.clone(), scale: view.camera.camera3D.scale.clone(), position: view.camera.camera3D.position.clone()};
                            // Launch preview of last computed orientation
                            showResection();
                        }
                    }

                }


            }, false);

            document.addEventListener('mouseup', (event) => {}, false);

            function createTexturedPlane(textureUrl, opacity) {
                var texture;
                var geometry;
                var material;

                texture = new itowns.THREE.TextureLoader().load(textureUrl);
                geometry = new itowns.THREE.PlaneGeometry(1, 1, 32);
                material = new itowns.THREE.MeshBasicMaterial({
                    map: texture,
                    color: 0xffffff,
                    transparent: true,
                    opacity: opacity,
                });
                return new itowns.THREE.Mesh(geometry, material);
            }

            function transformTexturedPlane(camera, distance, plane) {
                var Yreel = 2 * Math.tan(itowns.THREE.Math.degToRad(camera.fov / 2)) * distance;
                var Xreel = camera.aspect * Yreel;

                // set position and scale
                plane.scale.set(Xreel, Yreel, 1);
                plane.position.set(0, 0, -distance);

                plane.updateMatrixWorld();
            }

            // eslint-disable-next-line no-unused-vars
            function setupPictureFromCamera(camera, imageUrl, opacity, distance) {
                // create a textured plane, representing the picture.
                var plane = createTexturedPlane(imageUrl, opacity);
                camera.add(plane);

                transformTexturedPlane(camera, distance, plane);

                return plane;
            }

            // set camera settings to view.camera, even the up vector !
            // eslint-disable-next-line no-unused-vars
            function setupViewCameraDecomposing(view, camera) {
                mouseWheelOn = false;
                //camera.matrixWorld.decompose(viewCamera.position, viewCamera.quaternion, viewCamera.scale);
                t = 0;
                interpolateCam(view, camera);
            }

            var t = 0;
            var inc = 0.004;
            function interpolateCam(view, camera){
                if(t < 1. && !mouseWheelOn){
                    var viewCamera = view.camera.camera3D;
                    viewCamera.quaternion.slerp( camera.quaternion, t += inc );
                    viewCamera.position.lerp( camera.position, t += inc );
                    viewCamera.scale.lerp( camera.scale, t += inc );
                    view.notifyChange();
                    requestAnimationFrame(function(){interpolateCam(view,camera);});
                }
            }

            // add a camera helper to debug camera position..
            // eslint-disable-next-line no-unused-vars
            function addCameraHelper(view, camera) {
                var cameraHelper = new itowns.THREE.CameraHelper(camera);
                view.scene.add(cameraHelper);
                cameraHelper.updateMatrixWorld(true);
            }

            // Filtering functions
            function filterDates(t0, t1){
                var cams = sceneAllCams.children;
                for(var i in cams){
                    var cam = cams[i];
                    var t0Cam = new Date(cam.propAdded.t0);
                    var year = 1900 + t0Cam.getYear();
                    if(Math.abs(year - t0) < 1){
                        cam.visible = true;
                    }else{
                        cam.visible = false;
                    }

                }
            }

            // Filter between georeferenced and not georeferenced images
            function filterThumbnails(){
                var isChecked = document.getElementById("switchButton").checked;
                var table = document.getElementById('myTable');
                var nbRows = table.rows.length;
                let currentRow = table.rows[0];
                if ( !currentRow ) return;

                // GET THE CELLS COLLECTION OF THE CURRENT ROW.
                var objCells = currentRow.cells;
                var display = "display:none;"

                if(!isChecked){
                    display = 'table-row';
                }

                // LOOP THROUGH EACH CELL OF THE CURENT ROW TO READ CELL VALUES.
                for (var j = 0; j < objCells.length; j++) {
                   if(!objCells[j].innerHTML.includes("style"))  // Ugly way to detect georeferenced image because they have style for border
                        objCells[j].style = display;

                }

            }
          document.getElementById("switchButton").addEventListener("change", filterThumbnails);
          document.getElementById("goButton").addEventListener("click", event => { computeResection(event, imName, true); });

          if (imgName) {
                var source = new FetchSource('data/test/');
		const name = 'Orientation-' + imgName + '.jpg.xml';
                source.open('Ori-Aspro/' + name, 'text') // change orientation file each time you change the picture!
                    .then(data => Parsers.MicmacParser.parse(data, source, name))
                    .then(handleOrientation)
                    .then(hideShow)   
                    .catch(() => {

          const xparam = urlSearchParams.get('X');
          const yparam = urlSearchParams.get('Y');
          if (xparam && yparam) { 
               console.log('Travelling to ( '+xparam+' , '+yparam+' )');
               const coord = new itowns.Coordinates('EPSG:2154', Number(xparam), Number(yparam));
               console.log(coord);
               travelTo(coord);
	  } else if (locationParam && locationParam !== "-") {
               console.log('Travelling to '+locationParam);
	       document.getElementById("nameLocation").value = locationParam;
               geocode(locationParam).then(travelTo);
	  }

	});

	  }

	 if (imgName) {
               const img = document.getElementById("img");
               const src = "http://search-engine.alegoria-project.fr/api/v0_1/images/" + imgName;

               // download the image
               img.onload = function () {
                 // setup micmac processing
                 initXML2D(imgName+".jpg");
                 initXML3D(imgName+".jpg");
                 createCalib(); // We create a calibration file knowing just the image size
                 createMicmacChantierDescripteur(); // We create the micmac chantier descriptor
	       }
               img.src = src;
               
	       // upload it for micmac processing
               fetch(src)
               .then(response => response.blob())
               .then((blob) => {
//                 const file = new File([blob], imName, {type: blob.type});
                 const file = new File([], imName, {type: blob.type});
                 const formData = new FormData();
                 formData.append('files[]', file);
                 const url = 'php/process.php';
                 fetch(url, {
                      method: 'POST',
                      body: formData
                  }).then(response => {
			console.log(response);
                  });
              });


              const formData = new FormData();
              formData.append('identity', imgName);
              formData.append('fond', 'LAPIE'); // unused
              const getImageInfo = "http://search-engine.alegoria-project.fr/api/v0_1/metadata/"+imgName+"/getInfo";
            
              fetch(getImageInfo)
              .then(response => response.json())
              .then(json => {
                  const infos = json.infoImg.results.bindings[0];
                  console.log(infos);
                  const p = document.getElementById('info');
                  if (!infos) return;
                  p.innerHTML = "<ul>";
                  if (infos.institution) p.innerHTML += "<li>Institution : " + infos.institution.value + "</li>";
                  if (infos.fond) p.innerHTML += "<li>Fond : " + infos.fond.value + "</li>";
                  if (infos.title) p.innerHTML += "<li>Titre : <a href=\"" + infos.record.value+"\">"+infos.title.value + "</a></li>";
                  if (infos.nomFichierImage) p.innerHTML += "<li>Image : <a href=\"http://search-engine.alegoria-project.fr/api/v0_1/images/" + infos.nomFichierImage.value+"\">"+infos.nomFichierImage.value + "</a></li>";
                  if (infos.nomLieu) p.innerHTML += "<li>Lieu : <a href=\"" + infos.lieu.value+"\">"+infos.nomLieu.value + "</a></li>";
                  p.innerHTML += "</ul>";
                  if (infos.comments) p.innerHTML += "<span>" + infos.comments.value + "</span>";
              });         
           }

</script>
    </body>
</html>
